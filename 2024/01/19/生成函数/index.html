

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="qionghua">
  <meta name="keywords" content="">
  
    <meta name="description" content="生成函数 参考资料： 多项式与生成函数教程合集_x+2y+3z&#x3D;1000 生成函数-CSDN博客 zscoder博客中在算法竞赛中的生成函数（第一部分）：https:&#x2F;&#x2F;codeforces.com&#x2F;blog&#x2F;entry&#x2F;77468 zscoder博客中在算法竞赛中的生成函数（第二部分）：https:&#x2F;&#x2F;codeforces.com&#x2F;blog&#x2F;entry&#x2F;77551 什么是生成函数">
<meta property="og:type" content="article">
<meta property="og:title" content="生成函数">
<meta property="og:url" content="http://example.com/2024/01/19/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="生成函数 参考资料： 多项式与生成函数教程合集_x+2y+3z&#x3D;1000 生成函数-CSDN博客 zscoder博客中在算法竞赛中的生成函数（第一部分）：https:&#x2F;&#x2F;codeforces.com&#x2F;blog&#x2F;entry&#x2F;77468 zscoder博客中在算法竞赛中的生成函数（第二部分）：https:&#x2F;&#x2F;codeforces.com&#x2F;blog&#x2F;entry&#x2F;77551 什么是生成函数">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-01-19T09:01:44.000Z">
<meta property="article:modified_time" content="2024-01-19T09:10:47.994Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>生成函数 - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>qionghua</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/xianjian.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="生成函数"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-19 17:01" pubdate>
          2024年1月19日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.6k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          81 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">生成函数</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="生成函数">生成函数</h1>
<p>参考资料：</p>
<p><a
target="_blank" rel="noopener" href="https://blog.csdn.net/jiahonghao2002/article/details/126089862">多项式与生成函数教程合集_x+2y+3z=1000
生成函数-CSDN博客</a></p>
<p>zscoder博客中在算法竞赛中的生成函数（第一部分）：<a
target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/77468">https://codeforces.com/blog/entry/77468</a></p>
<p>zscoder博客中在算法竞赛中的生成函数（第二部分）：<a
target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/77551">https://codeforces.com/blog/entry/77551</a></p>
<p><strong>什么是生成函数</strong></p>
<p>我们现在有一个数列 <span
class="math inline">\(a_0,a_1,a_2...\)</span>
。我们通过构建数列项和多项式中项的系数关系将数列 <span
class="math inline">\(a\)</span> 和多项式 <span
class="math inline">\(A\)</span> 关联起来。</p>
<p>一般来说，对于一个数列 <span
class="math inline">\(\{a_i\}_{i=0}^{\infty}\)</span>，我们定义这个数列的<strong>一般生成函数（<span
class="math inline">\(OGF\)</span>）</strong>为 <span
class="math inline">\(A(x)=\sum\limits_{i=0}^{\infty}a_ix^i\)</span>。</p>
<p>举一个简单的例子，考虑斐波那契数列 <span
class="math inline">\(f\)</span> 为 <span
class="math inline">\(1,1,2,3,5,8,...\ \)</span>。那么这个数列的 <span
class="math inline">\(OGF\)</span> 为 <span
class="math inline">\(F(x)=0+x+x^2+2x^3+3x^4+5x^5+8x^6+...\
\)</span>。</p>
<p>你可以想象是将数列中的每一项（可能是无限多项）按序放入多项式中的每一项的系数中。通过把多项式中每一项都加起来，就会得到一个系数为数列中的每一项构成的
“无穷多项式”
。构建生成函数的好处就是可以通过生成函数来发现一些数列的惊人性质。</p>
<p>实际上有很多种的生成函数，例如指数生成函数（<span
class="math inline">\(EGF\)</span>）和狄利克雷生成函数。在后面都会一一介绍。</p>
<p>最后为了方便我们引入一个符号：对于一个级数 <span
class="math inline">\(A(x)=\sum\limits_{n \geq0}a_nx^n\)</span> ，我们记
<span class="math inline">\([x^n]A(x)=a_n\)</span> （即 <span
class="math inline">\(A\)</span> 中 <span
class="math inline">\(x^n\)</span> 的系数）。</p>
<p><strong><span
class="math inline">\(OGF\)</span>的一些简单例子</strong></p>
<p>我们令数列 <span class="math inline">\(a\)</span> 为 <span
class="math inline">\(1,1,1,...\)</span>，那么根据上述的定义，数列 <span
class="math inline">\(a\)</span> 的 <span
class="math inline">\(OGF\)</span> 就是 <span
class="math inline">\(A(x)=1+x+x^2+x^3+...\)</span>，观察其实可以发现，
<span class="math inline">\(A(x)\)</span> 实际上是一个公比为 <span
class="math inline">\(x\)</span>
的几何级数，也就是说根据等比数列求和公式可以得到 <span
class="math inline">\(A(x) = \frac{1}{1-x}\)</span>。</p>
<p>注意：我们并不关系级数的敛散性（例如上述级数在 <span
class="math inline">\(|x|&lt;1\)</span>
是否成立），这取决于你使用级数要做什么事情。在生成函数和大多数情况下，我们将级数视为形式幂级数，我们不需要关心形式幂级数的敛散性问题。但是这并不意味着能随意将参数
<span class="math inline">\(x\)</span>
带入任意常数，如果确实需要替换值，那么就需要考虑敛散性问题，只有级数收敛才能带入值到
<span class="math inline">\(x\)</span> 中。</p>
<p>我们也可以利用一些代数式的方式和技巧来化简生成函数式，下面是一些典型的例子。</p>
<p><strong>斐波那契数列的普通生成函数</strong></p>
<p>在上面介绍生成函数时，我们也提及了斐波那契数列 <span
class="math inline">\(f\)</span>
，现在我们就需要计算该数列的封闭形式。</p>
<p>考虑数列 <span class="math inline">\(f_n\)</span> 定义为 <span
class="math inline">\(f_0=0,f_1=1\)</span> 并且对于 <span
class="math inline">\(n&gt;2\)</span>有 <span
class="math inline">\(f_n=f_{n-1}+f_{n-2}\)</span> ，计算 <span
class="math inline">\(f_n\)</span> 的生成函数的封闭形式。</p>
<p>首先为了凑出多项式的形式，最简单的方法就是等式两边同时乘以 <span
class="math inline">\(x^n\)</span> ，最终得到 <span
class="math display">\[
f_nx^n=f_{n-1}x^n+f_{n-2}x^n
\]</span> 接下来，我们对两边同时求和得到： <span class="math display">\[
\sum_{n=2}^{\infty}f_nx^n=x\sum_{n=2}^{\infty}f_{n-1}x^{n-1}+x^2\sum_{n=2}^{\infty}f_{n-2}x^{n-2}
\]</span> 根据定义，我们知道： <span class="math display">\[
F(x)=\sum_{n=0}^{\infty}f_nx^n
\]</span> 那么和式部分就能化简成以下形式： <span class="math display">\[
\begin{align*}
&amp;F(x)-f_0-f_1x=x(F(x)-f_0)+x^2F(x)\\
\Rightarrow &amp;F(x)-x=xF(x)+x^2F(x)\\
\Rightarrow&amp;F(x)(1-x-x^2)=x\\
\Rightarrow&amp;F(x)=\frac{x}{1-x-x^2}
\end{align*}
\]</span> 那么最终我们就得到了斐波那契数列的生成函数的封闭形式</p>
<p><strong><span
class="math inline">\(Catalan\)</span>数列的普通生成函数</strong></p>
<p>卡特兰数时组合数学中一个常出现于各种计数问题的数列。 卡特兰数 <span
class="math inline">\(C_n\)</span> 满足以下递推关系：</p>
<ol type="1">
<li><span
class="math inline">\(C_{n+1}=C_0C_n+C_1C_{n-1}+...+C_nC_0\)</span></li>
<li><span
class="math inline">\((n-3)C_n=\frac{n}{2}(C_3C_{n-1}+C_4C_{n-2}+C_5C_{n-3}+...+C_{n-2}C_4+C_{n-1}C_3)\)</span></li>
</ol>
<p>考虑 <span class="math inline">\(Catalan\)</span> 数列 <span
class="math inline">\(c_n\)</span> 定义为 <span
class="math inline">\(c_0=1\)</span> 并且对于 <span
class="math inline">\(n&gt;0\)</span> 都有 <span
class="math inline">\(c_{n+1}=\sum\limits_{i=0}^nc_ic_{n-i}\)</span>，计算其生成函数的封闭形式。</p>
<p>那么根据斐波那契数列一样的思路，我们对等式两边同时乘以 <span
class="math inline">\(x^n\)</span> 并同时求和，得到： <span
class="math display">\[
\sum_{n=0}^{\infty}c_{n+1}x^{n+1}=\sum_{n=0}^{\infty}\sum_{i=0}^nc_ic_{n-i}x^{n+1}
\]</span> 我们对等式右边采取这样的拆分形式： <span
class="math display">\[
\sum_{n=0}^{\infty}\sum_{i=0}^nc_ic_{n-i}x^{n+1}=x\sum_{n=0}^{\infty}\sum_{i=0}^nc_ic_{n-i}x^{n}=x\sum_{n=0}^{\infty}\sum_{i=0}^n\
(c_ix^i)\times (c_{n-i}x^{n-i})
\]</span> 那么 <span class="math inline">\((c_ix^i)\times
(c_{n-i}x^{n-i})\)</span> 的形式比较让我们容易联想到使用 <span
class="math inline">\(C(x)^2\)</span> 的方式来进行解决，我们将 <span
class="math inline">\(C(x)^2\)</span> 展开： <span
class="math display">\[
C(x)^2=(c_0+c_1x+c_2x^2+...)(c_0+c_1x+c_2x^2+...)
\]</span> 观察可以发现，在第一个括号选取 <span
class="math inline">\(x^i\)</span> 和在第二个括号选取 <span
class="math inline">\(x^{n-i}\)</span>，那么就能得到 <span
class="math inline">\(x^n\)</span> 的系数，也就是说，在 <span
class="math inline">\(C(x)^2\)</span> 中，<span
class="math inline">\(x^n\)</span> 项的系数就是 <span
class="math inline">\(\sum\limits_{i=0}^nc_ic_{n-i}\)</span>。</p>
<p>得到了这一点，我们就能将原式转化成： <span class="math display">\[
C(x)-c_0=xC(x)^2
\]</span> 同时 <span
class="math inline">\(c_0=1\)</span>，原式就转化为： <span
class="math display">\[
xC(x)^2-C(x)+1=0
\]</span> 很明显，这就是一个一元二次方程，最终解得： <span
class="math display">\[
C(x) = \frac{1\pm\sqrt{1-4x}}{2x}
\]</span> 虽然我们最终得到了 <span
class="math inline">\(C(x)\)</span>，但是问题也随之而来，分子中的符号应该是取正还是取负。首先我们定义的
<span class="math inline">\(Catalan\)</span> 数列的第一项 <span
class="math inline">\(c_0=1\)</span>，也就是说级数应该在 <span
class="math inline">\(x=0\)</span> 处收敛至 <span
class="math inline">\(1\)</span> 才对，然后观察正负号在 <span
class="math inline">\(x=0\)</span> 处的敛散性。</p>
<p>当分子中的符号取正号时，当 <span
class="math inline">\(x\rightarrow0\)</span> 时，分子 <span
class="math inline">\(\rightarrow2\)</span> 而分母 <span
class="math inline">\(\rightarrow0\)</span> ，也就是说此时级数在 <span
class="math inline">\(x\rightarrow0\)</span> 处发散。
当分子中的符号取负号时，当 <span
class="math inline">\(x\rightarrow0\)</span> 时，分子 <span
class="math inline">\(\rightarrow0\)</span> 并且分母 <span
class="math inline">\(\rightarrow0\)</span>，那根据洛必达法则就很很明显的知道这个级数在
<span class="math inline">\(x=0\)</span> 处收敛至 <span
class="math inline">\(1\)</span>。</p>
<p>因此最终得到： <span class="math display">\[
C(x) = \frac{1-\sqrt{1-4x}}{2x}
\]</span>
可以尝试寻找一些经典数列，并计算其生成函数的封闭形式，这对形成看到函数递归式就能想到生成函数的直觉有所帮助。</p>
<h4 id="多变量参数的ogf">多变量参数的<span
class="math inline">\(OGF\)</span></h4>
<p>我们不能将自己局限在一个变量上，考虑多变量参数的 <span
class="math inline">\(OGF\)</span>，下面我们会举一些例子。</p>
<p><strong>二项式系数 <span
class="math inline">\(OGF\)</span></strong></p>
<p>二项式系数 <span class="math inline">\(b(n,k)=C_n^k\)</span>
被定义为对于 <span class="math inline">\(n\geq0,\
b(n,0)=1\)</span>，对于 <span class="math inline">\(n\geq1,\
b(0,n)=0\)</span> 并且对于 <span class="math inline">\(n,k\geq1,\
b(n,k)=b(n-1,k)+b(n-1,k-1)\)</span>。计算 <span
class="math inline">\(b(n,k)\)</span> 的生成函数的封闭形式。</p>
<p>我们定义 <span class="math inline">\(B(x,y)\)</span> 的展开形式为
<span
class="math inline">\(\sum\limits_{n\geq0}\sum\limits_{k\geq0}b(n,k)x^ny^k\)</span>。那么我们根据之前的策略，得到：
<span class="math display">\[
\sum\limits_{n\geq1}\sum\limits_{k\geq1}b(n,k)x^ny^k=x\sum\limits_{n\geq1}\sum\limits_{k\geq1}b(n-1,k)x^{n-1}y^k+xy\sum\limits_{n\geq1}\sum\limits_{k\geq1}b(n-1,k-1)x^{n-1}y^{k-1}
\]</span> 化简得到： <span class="math display">\[
\begin{align*}
&amp;B(x,y)-\sum_{n\geq0}x^n=x(B(x,y)-\sum_{n\geq0}x^n)+xyB(x,y)\\
\Rightarrow&amp;B(x,y)-\frac{1}{1-x}=xB(x,y)-\frac{x}{1-x}+xyB(x,y)\\
\Rightarrow&amp;B(x,y)-xB(x,y)-xyB(x,y)=1\\
\Rightarrow&amp;B(x,y)=\frac{1}{1-x-xy}
\end{align*}
\]</span> 最终得到二项式系数 <span class="math inline">\(OGF\)</span>
为：<span class="math inline">\(B(x,y)=\frac{1}{1-x-xy}\)</span></p>
<p>我们可以利用得到的二项式系数 <span class="math inline">\(OGF\)</span>
来推导出很多有趣的一元变量参数的 <span
class="math inline">\(OGF\)</span>。例如，我们将 <span
class="math inline">\(B(x,y)\)</span> 看做是关于 <span
class="math inline">\(x\)</span> 的幂级数，将 <span
class="math inline">\(y\)</span> 视为常量： <span
class="math display">\[
B(x,y)=\frac{1}{1-x-xy}=\frac{1}{1-(y+1)x}
\]</span> 此时我们将 <span class="math inline">\((y+1)x\)</span>
视为一个整体，那么原式就会被我们转化为： <span class="math display">\[
B(x,y)=\sum_{k=0}^{\infty}\ ((y+1)x)^k=\sum_{k=0}^{\infty}(y+1)^kx^k
\]</span> 此时由于 <span class="math inline">\(y\)</span>
被视为常量，那么我们就会得到 <span
class="math inline">\([x^n]B(x,y)=(y+1)^n\)</span>。同时根据定义，<span
class="math inline">\([x^n]B(x,y)=\sum\limits_{k=0}^{\infty}b(n,k)y^k\)</span>，那么
<span
class="math inline">\(\sum\limits_{k=0}^{\infty}b(n,k)y^k=(y+1)^n\)</span>。这时候我们就发现，这不就和
<span class="math inline">\((y+1)^n\)</span>
二项式展开的结果一模一样。</p>
<p>如果我们将 <span class="math inline">\(B(x,y)\)</span> 看做是关于
<span class="math inline">\(y\)</span> 的幂级数呢？，那么就变成了：
<span class="math display">\[
B(x,y)=\frac{1}{1-x-xy}=\frac{\frac{1}{1-x}}{1-\frac{x}{1-x}y}=\frac{1}{1-x}\sum_{k=0}^{\infty}(\frac{x}{1-x})^ky^k=\sum_{k=0}^{\infty}\frac{x^k}{(1-x)^{k+1}}y^k
\]</span> 同样的我们也能得到 <span
class="math inline">\([y^k]B(x,y)=\frac{x^k}{(1-x)^{k+1}}\)</span>，那么
<span
class="math inline">\(\sum\limits_{n=0}^{\infty}b(n,k)x^n=\frac{x^k}{(1-x)^{k+1}}\)</span>，此时我们就得到了
<span class="math inline">\(\frac{1}{(1-x)^{k+1}}\)</span>
的二项式展开结果。</p>
<p>根据上述结果我们可以得到 <span
class="math inline">\([x^{n-k}]\frac{1}{(1-x)^{k+1}}=C_n^k\)</span>，那么进行恒等变形我们就可以得到
<span
class="math inline">\([x^n]\frac{1}{(1-x)^{k}}=C_{n+k-1}^{k-1}\)</span>。</p>
<p>而这个等式在我们处理二项式系数求和的时候并且 <span
class="math inline">\(k\)</span> 是固定而 <span
class="math inline">\(n\)</span> 是变量的情况下是非常有用的。</p>
<h4 id="指数生成函数">指数生成函数</h4>
<p>定义：让 <span class="math inline">\(a_0,a_1,a_2,...\)</span>
是一个数列。然后数列 <span class="math inline">\(a\)</span>
的指数生成函数（<span class="math inline">\(EGF\)</span>）定义为 <span
class="math inline">\(A(x)=\sum\limits_{i=0}^{\infty}\frac{a_i}{i!}x^i\)</span></p>
<p>换句话说，指数生成函数仅仅实在普通生成函数的基础之上，将系数除以
<span class="math inline">\(i!\)</span> 。</p>
<p><strong><span class="math inline">\(Bell\)</span>
数的指数生成函数</strong></p>
<p><span class="math inline">\(Bell\)</span> 数指的是将集合 <span
class="math inline">\({1,2,3,...,n}\)</span>
拆成不相交集合的方案数。例如集合 <span
class="math inline">\(\{1,2,3\}\)</span> 可以拆成 <span
class="math inline">\(123;12,3;13,2;1,23;1,2,3\)</span>
总共五种方案。</p>
<p>让我们令 <span class="math inline">\(b_n\)</span> 是第 <span
class="math inline">\(n\)</span> 个 <span
class="math inline">\(Bell\)</span> 数，那么根据上述的例子 <span
class="math inline">\(b_3=5\)</span>，现在我们需要计算其指数生成函数。</p>
<p>当我们面对的数据量是 <span class="math inline">\(n\leq5000\)</span>
时，我们可以 <span class="math inline">\(DP\)</span>
的方式来统计方案数。</p>
<p>假设我们元素 <span class="math inline">\(1\)</span>
所在的集合的元素个数为 <span
class="math inline">\(i\)</span>，那么划分剩下的 <span
class="math inline">\(n-i\)</span> 个元素的方案数为 <span
class="math inline">\(b_{n-i}\)</span>，同时选择 <span
class="math inline">\(i-1\)</span> 个元素的方案数为 <span
class="math inline">\(C_{n-1}^{i-1}\)</span>
。因此根据乘法原理和加法原理就有： <span class="math display">\[
b_n=\sum_{i=1}^nC_{n-1}^{i-1}b_{n-i}=\sum_{i=0}^{n-1}C_{n-1}^ib_{n-i-1}=\sum_{i=0}^{n-1}C_{n-1}^{n-1-i}b_{n-i-1}=\sum_{i=0}^{n-1}C_{n-1}^ib_i
\]</span> 那么只要预处理组合数，就会得到一个 <span
class="math inline">\(O(n^2)\)</span> 的 <span
class="math inline">\(DP\)</span>。在当前的数据量时，是可以通过的，但是如果将数据范围提高到
<span class="math inline">\(n\leq3\times10^5\)</span>
的时候，就只能使用指数生成函数了。 <span class="math display">\[
\begin{align*}
&amp;b_n=\sum_{i=0}^{n-1}C_{n-1}^ib_i=\sum_{i=0}^{n-1}\frac{(n-1)!}{i!(n-1-i)!}b_i\\
\Rightarrow&amp;\frac{b_n}{(n-1)!}=\sum_{i=0}^{n-1}\frac{b_i}{i!}\cdot\frac{1}{(n-1-i)!}\\
\Rightarrow&amp;n\frac{b_n}{n!}=\sum_{i=0}^{n-1}\frac{b_i}{i!}\cdot\frac{1}{(n-1-i)!}\\
\Rightarrow&amp;\sum_{n=1}^{\infty}n\frac{b_n}{n!}x^n=\sum_{n=1}^{\infty}x\sum_{i=0}^{n-1}\frac{b_ix^i}{i!}\cdot\frac{x^{n-1-i}}{(n-1-i)!}
\end{align*}
\]</span>
现在我们看到了，为什么指数生成函数对于上面的问题很方便，如果我们的卷积包含二项式系数（通常我们在处理组合问题的时候会遇到），使用
<span class="math inline">\(EGF\)</span>
将会自动帮助我们对其卷积形式（详细会在后面的卷积部分提及到）</p>
<p>回到我们上面推出的式子，根据定义来说，等式的右边就是 <span
class="math inline">\(B(x)\)</span> 和 <span
class="math inline">\(e^x\)</span> 的卷积，那么等式右边就变成了 <span
class="math inline">\(xB(x)e^x\)</span> 。（为什么是 <span
class="math inline">\(e^x\)</span> ，回想 <span
class="math inline">\(e^x\)</span> 的麦克劳林展开式，<span
class="math inline">\(e^x=\sum\limits_{n\geq0}\frac{x^n}{n!}\)</span>）
等式的左边就需要做一点工作，因为是我们讨厌的 <span
class="math inline">\(nb_n\)</span> 而不是 <span
class="math inline">\(b_n\)</span>
。而处理这个问题，我们就需要一个处理幂级数的常见技巧，对 <span
class="math inline">\(B(x)\)</span> <strong>求导</strong>，然后再乘一个
<span class="math inline">\(x\)</span> 。 我们验证一下，令 <span
class="math inline">\(A(x)=a_0+a_1x+a_2x^2+...=\sum\limits_{n\geq0}a_ix^n\)</span>
是幂级数，那么 <span
class="math inline">\(xA&#39;(x)=a_1x+2a_2x^2+3a_3x^3+...=\sum\limits_{n\geq0}na_nx^n\)</span>
。 最终上面的式子就变成了 <span
class="math inline">\(xB&#39;(x)=xB(x)e^x\)</span>，也就是 <span
class="math inline">\(\frac{B&#39;(x)}{B(x)}=e^x\)</span>
。根据我们高数学习到的知识，这是什么？这是变量可分离性的一阶微分方程。我们将
<span class="math inline">\(B(x)\)</span> 看成 <span
class="math inline">\(y\)</span>，那么就会变成： <span
class="math display">\[
\begin{align*}
&amp;\frac{y&#39;}{y}=e^x\\
\Rightarrow&amp;\frac{\frac{dy}{dx}}{y}=e^x\\
\Rightarrow&amp;\frac{dy}{y}=e^xdx
\end{align*}
\]</span> 两边同时进行积分就能得到： <span class="math display">\[
lnB(x)=e^x+C
\]</span> 我们已知 <span class="math inline">\(b_0=1，B(0)=1\)</span>
就会得到 <span class="math inline">\(C=-1\)</span> ，那么： <span
class="math display">\[
\begin{align*}
&amp;lnB(x)=e^x-1\\
\Rightarrow&amp;B(x)=e^{e^x-1}
\end{align*}
\]</span> 最终我们就得到了我们想要的 <span
class="math inline">\(EGF\)</span>，尽管在形式上可能有点奇怪。</p>
<p>无论如何，在学习过多项式的算法之后，我们知道能在 <span
class="math inline">\(O(nlogn)\)</span> 的时间下计算出多项式 <span
class="math inline">\(e^{P(x)}\)</span> 的前 <span
class="math inline">\(n\)</span> 项系数。</p>
<h4 id="生成函数的代数技巧">生成函数的代数技巧</h4>
<p>这部分会讲解一些操作生成函数的方法，我们将 <span
class="math inline">\(a_i\)</span> 和 <span
class="math inline">\(b_i\)</span> 代表生成函数 <span
class="math inline">\(A(x)\)</span> 和 <span
class="math inline">\(B(x)\)</span> 的第 <span
class="math inline">\(i\)</span> 项系数。</p>
<p><strong>加法</strong></p>
<p>对于生成函数，<span class="math inline">\(C(x)=A(x)+B(x)\)</span>
生成数列 <span class="math inline">\(c_n=a_n+b_n\)</span></p>
<p><strong>平移</strong></p>
<p>对于 <span class="math inline">\(OGF\)</span> ，<span
class="math inline">\(C(x)=x^kA(x)\)</span> 生成数列 <span
class="math inline">\(c_n=a_{n-k},(a_i=0,i&lt;0)\)</span>。对于 <span
class="math inline">\(EGF\)</span>，需要对 <span
class="math inline">\(A(x)\)</span> 积分 <span
class="math inline">\(k\)</span> 次来达到同样的效果。</p>
<p>对于 <span class="math inline">\(OGF\)</span> ，<span
class="math inline">\(C(x)=\frac{A(x)-(a_0+a_1x^1+a_2x^2+...+a_{k-1}x^{k-1})}{x^k}\)</span>
生成数列 <span class="math inline">\(c_n=a_{n+k}\)</span></p>
<p>对于 <span class="math inline">\(EGF\)</span>，<span
class="math inline">\(C(x)=A^{(k)}(x)\)</span> 生成数列 <span
class="math inline">\(c_n=a_{n+k}\)</span></p>
<p><strong>乘以 <span class="math inline">\(n\)</span></strong></p>
<p>对于 <span class="math inline">\(OGF\)</span> 和 <span
class="math inline">\(EGF\)</span>，<span
class="math inline">\(C(x)=xA&#39;(x)\)</span> 的生成数列 <span
class="math inline">\(c_n=na_n\)</span></p>
<p><strong>卷积</strong></p>
<p>卷积对于生成函数来说是一个相当重要的操作。</p>
<p>对于 <span class="math inline">\(OGF\)</span> 来说，<span
class="math inline">\(C(x)=A(x)B(x)\)</span> 生成数列 <span
class="math inline">\(c_n=\sum\limits_{k=0}^na_kb_{n-k}\)</span> 。</p>
<p>对于 <span class="math inline">\(EGF\)</span> 来说，<span
class="math inline">\(C(x)=A(x)B(x)\)</span> 生成数列 <span
class="math inline">\(c_n=\sum\limits_{k=0}^nC_n^ka_kb_{n-k}\)</span> 。
证明：<span
class="math inline">\(A(x)=\sum\limits_{k=0}^{\infty}\frac{a_k}{k!}x^k\)</span>，<span
class="math inline">\(B(x)=\sum\limits_{k=0}^{\infty}\frac{b_k}{k!}x^k\)</span>，跟
<span class="math inline">\(OGF\)</span> 同样的方式，得到 <span
class="math inline">\(x^n\)</span> 的系数必然是 <span
class="math inline">\(\sum\limits_{k=0}^{n}\frac{a_k}{k!}\cdot\frac{b_{n-k}}{(n-k)!}\cdot
x^n\)</span> 。同时 <span
class="math inline">\(C(x)=\sum\limits_{k=0}^{\infty}\frac{c_k}{k!}x^k\)</span>，也就是说
<span class="math inline">\(k=n\)</span> 时，对应的就是 <span
class="math inline">\(c_n\frac{x^n}{n!}\)</span>
。那么我们对刚才得到的系数做一下恒等变形，变成 <span
class="math inline">\(\sum\limits_{k=0}^{n}\frac{n!}{k!(n-k)!}a_kb_{n-k}\frac{x^n}{n!}\)</span>，也就是
<span
class="math inline">\(\sum\limits_{k=0}^{n}C_n^ka_kb_{n-k}\frac{x^n}{n!}\)</span>，最终得到
<span
class="math inline">\(c_n=\sum\limits_{k=0}^nC_n^ka_kb_{n-k}\)</span>
。</p>
<p>这也就是为什么说 <span class="math inline">\(EGF\)</span>
能够处理菜二项式系数或是阶乘的递归式。</p>
<p><strong>生成函数的幂</strong></p>
<p>生成函数的幂也是卷积的一种形式，称为自卷积：</p>
<p>对于 <span class="math inline">\(OGF\)</span>，<span
class="math inline">\(C(x)=A(x)^k\)</span> 生成数列 <span
class="math inline">\(c_n=\sum\limits_{i1+i2+...+ik=n}a_{i1}a_{i2}...a_{ik}\)</span></p>
<p>对于 <span class="math inline">\(EGF\)</span>，<span
class="math inline">\(C(x)=A(x)^k\)</span> 生成数列 <span
class="math inline">\(c_n=\sum\limits_{i1+i2+...+ik=n}\frac{n!}{i_1!i_2!...i_k!}a_{i1}a_{i2}...a_{ik}\)</span></p>
<p><strong>前缀和技巧</strong></p>
<p>前缀和技巧只对 <span class="math inline">\(OGF\)</span>
有效，假设我们想构造数列 <span
class="math inline">\(c_n=a_0+a_1+...+a_n\)</span>，那么我们可以令 <span
class="math inline">\(C(x)=\frac{1}{1-x}A(x)\)</span>，也就是 <span
class="math inline">\(\sum\limits_{n\geq0}x^n\)</span> 和 <span
class="math inline">\(\sum\limits_{n\geq0}a_nx^n\)</span> 做卷积。</p>
<p><strong>常见数列的生成函数</strong></p>
<p>单位常系数数列生成函数： <span class="math display">\[
\frac{1}{1-x}=1+x+x^2+...=\sum_{n=0}^{\infty}x^n
\]</span> 调和数列生成函数： <span class="math display">\[
-ln(1-x)=x+\frac{x^2}{2}+\frac{x^3}{3}+...=\sum_{n=1}^{\infty}\frac{x^n}{n}
\]</span> 单位常系数数列的 <span class="math inline">\(EGF\)</span>
（<span class="math inline">\(e^x\)</span> 的麦克劳林展开）： <span
class="math display">\[
e^x=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+...=\sum_{n=0}^{\infty}\frac{x^n}{n!}
\]</span> 二项式系数的列向数列的生成函数： <span class="math display">\[
(1-x)^{-k}=C_{k-1}^0x^0+C_k^1x^1+C_{k+1}^2x^2+...=\sum_{n=0}^{\infty}C_{n+k-1}^nx^n
\]</span> 我们的目的就是将复杂的函数转换到我们已知的 <span
class="math inline">\(OGF\)</span> 或是 <span
class="math inline">\(EGF\)</span> 的封闭形式上去。</p>
<p>介绍了这么久，那么生成函数都有哪些应用场景呢，我们在下面开始介绍。</p>
<h4 id="在计数类问题中使用生成函数">在计数类问题中使用生成函数</h4>
<p>生成函数在排列组合类问题中是一个强有力的工具，下面我们会利用生成函数来解决经典的计数问题。</p>
<p><strong>重新回顾 <span class="math inline">\(Catalan\)</span>
数</strong></p>
<p>在上文我们已经求出 <span class="math inline">\(Catalan\)</span>
数列的 <span class="math inline">\(OGF\)</span> 是 <span
class="math inline">\(C(x)=\frac{1-\sqrt{1-4x}}{2x}\)</span>
。假设我们想找到关于 <span class="math inline">\(c_n\)</span>
的封闭形式，想对 <span class="math inline">\(C(x)\)</span>
进行展开，但平方根却显得十分麻烦。</p>
<p>这时候，就需要使用广义二项式定理来帮助我们解决问题，在此我们定义一下广义二项式的系数。</p>
<p>定义：令 <span class="math inline">\(r\)</span>
是任意的实数（其实也可以为复数）而 <span
class="math inline">\(n\)</span> 是非负整数，那么 <span
class="math inline">\(C_r^n=\frac{r(r-1)(r-2)...(r-n+1)}{n!}\)</span></p>
<p>这和二项式系数的定义差不多，只不过取消了对 <span
class="math inline">\(r\)</span> 是一个非负整数的要求。</p>
<p>那么广义二项式定理就是： <span class="math display">\[
(1+x)^r=\sum_{n=0}^{\infty}C_r^nx^n
\]</span> 证明：</p>
<p>令 <span class="math inline">\(f(x)=(1+x)^r\)</span>，那么 <span
class="math inline">\(f^{(n)}(x)=r(r-1)(r-2)...(r-n+1)(1+x)^{r-n}\)</span>
。</p>
<p>首先我们联想一下泰勒公式： <span class="math display">\[
f(x)=\frac{f(x_0)}{0!}+\frac{f&#39;(x_0)}{1!}(x-x_0)+\frac{f&#39;&#39;(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)
\]</span> 其中 <span class="math inline">\(R_n(x)\)</span> 是 <span
class="math inline">\(n\)</span> 阶泰勒余项。</p>
<p>此时由于 <span class="math inline">\(r\)</span>
是任意的实数，因此对于 <span
class="math inline">\(f(x)=(1+x)^r\)</span>，该函数会处于一种无限可导的情况，那么我们直接将泰勒公式展开到无限项：
<span class="math display">\[
f(x)=\sum_{n=0}^\infty\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n
\]</span> 此时右边部分我们称为泰勒级数，而当 <span
class="math inline">\(x_0=0\)</span> 时得到的级数称为麦克劳林级数，即：
<span class="math display">\[
f(x)=\sum_{n=0}^\infty\frac{f^{(n)}(0)}{n!}x^n
\]</span> 同时我们知道当 <span class="math inline">\(x=0\)</span>
时，<span
class="math inline">\(f^{(n)}(0)=r(r-1)(r-2)...(r-n+1)\)</span>，最终就得到：
<span class="math display">\[
f(x)=\sum_{n=0}^\infty\frac{r(r-1)(r-2)...(r-n+1)}{n!}x^n
\]</span> 也就是： <span class="math display">\[
\sum_{n=0}^{\infty}C_r^nx^n
\]</span>
证明完广义二项式定理的其中一个公式之后（其余更加详细的介绍见多项式的内容），我们再次回到
<span class="math inline">\(Catalan\)</span> 数列上。</p>
<p>现在 <span
class="math inline">\(\sqrt{1-4x}=(1-4x)^{\frac{1}{2}}=\sum\limits_{n=0}^\infty
C_{\frac{1}{2}}^n(-4x)^n\)</span> 。展开一下得到： <span
class="math display">\[
\begin{align*}
&amp;=\sum_{n=0}^\infty\frac{1}{2}\cdot\frac{-1}{2}\cdot\frac{-3}{2}\cdot...\cdot\frac{-(2n-3)}{2}\cdot\frac{1}{n!}\cdot(-4)^nx^n\\
&amp;=1+\sum_{n=0}^\infty\frac{(-1)^{n-1}(1\cdot3\cdot5\cdot...\cdot(2n-3))}{2^n}\cdot\frac{(-4)^n}{n!}\cdot
x^n\\
&amp;=1+\sum_{n=0}^\infty\frac{(-1)^{n-1}(2n-3)!!}{2^n}\cdot\frac{(-4)^n}{n!}\cdot
x^n\\
&amp;=1+\sum_{n=0}^\infty\frac{(-1)^{n-1}(2n-2)!}{2^n\cdot2^{n-1}\cdot(n-1)!}\cdot\frac{(-4)^n}{n!}\cdot
x^n((2n-1)!!=\frac{(2n)!}{2^nn!})\\
&amp;=1+\sum_{n=0}^\infty\frac{-2\cdot(2n-2)!}{(n-1)!n!}x^n\\
&amp;=1+\sum_{n=0}^\infty-\frac{2}{n}\cdot C_{2n-2}^{n-1}x^n
\end{align*}
\]</span> 因此： <span class="math display">\[
\begin{align*}
C(x) &amp;=
\frac{1-\sqrt{1-4x}}{2x}=\frac{1}{2x}\cdot(1-1-\sum_{n=0}^\infty-\frac{2}{n}\cdot
C_{2n-2}^{n-1}x^n)\\
&amp;=\frac{1}{2x}\cdot\sum_{n=0}^\infty \frac{2}{n}\cdot
C_{2n-2}^{n-1}x^n\\
&amp;=\sum_{n=0}^\infty \frac{1}{n+1}\cdot C_{2n}^{n}x^n\\
\end{align*}
\]</span> 那么我们就得到 <span class="math inline">\(Catalan\)</span>
数列的第 <span class="math inline">\(n\)</span> 项为 <span
class="math inline">\(c_n=\frac{1}{n+1}C_{2n}^n\)</span> 。</p>
<p><strong>解决排列类问题</strong></p>
<p>对于一个排列来说 <span
class="math inline">\(p=(p_1,p_2,...,p_n)\)</span> 考虑建边操作 <span
class="math inline">\(i\rightarrow
p_i\)</span>。我们会得到一些不相交的环。</p>
<p><strong>问题 <span class="math inline">\(1\)</span></strong>：<span
class="math inline">\(n\)</span> 个元素排列中生成 <span
class="math inline">\(k\)</span> 个环的方案数是多少？
这个问题称为第一类斯特林数。</p>
<p>让 <span class="math inline">\(c_n=(n-1)!\)</span> 是有 <span
class="math inline">\(n\)</span> 个元素不同环的数量。（其中 <span
class="math inline">\(n\)</span> 个元素的排列数是 <span
class="math inline">\(n!\)</span>，但由于环是一个首尾相接的排列，因此对于一个
<span class="math inline">\(n\)</span> 个元素的环，对应着 <span
class="math inline">\(n\)</span> 的不一样的排列，因此 <span
class="math inline">\(\frac{n!}{n}=(n-1)!\)</span>）让 <span
class="math inline">\(C(x)=\sum\limits_{n=0}^\infty\frac{c_n}{n!}x^n\)</span>
表示 <span class="math inline">\(c\)</span> 的 <span
class="math inline">\(EGF\)</span> ，让 <span
class="math inline">\(f_n\)</span> 和 <span
class="math inline">\(F(x)\)</span> 表示我们的答案数列和对应的 <span
class="math inline">\(EGF\)</span>。这里我们先给出一个结论：<span
class="math inline">\(F(x)=\frac{1}{k!}C(x)^k\)</span>。</p>
<p>首先我们先想这样一个问题：对 <span class="math inline">\(n\)</span>
个元素划分成 <span class="math inline">\(k\)</span>
个不同种类的方案数是多少？那么答案其实很明显就是 <span
class="math inline">\(\frac{n!}{a_1!a_2!...a_k!}\)</span>，其中 <span
class="math inline">\(a_1+a_2+...+a_k=n\)</span>。 <span
class="math display">\[
\begin{align*}
C_n^{a_1}C_{n-a_1}^{a_2}C_{n-a_1-a_2}^{a_3}...C_{n-a_1-...-a_{k-1}}^{a_k}&amp;=\frac{n!}{a_1!(n-a_1)!}\cdot\frac{(n-a_1)!}{a_2!(n-a_1-a_2)!}\cdot...\cdot\frac{(n-a_1-a_2-...-a_{k-1})!}{a_k!(n-a_1-a_2-...-a_{k-1}-a_k)!}\\
&amp;=\frac{n!}{a_1!a_2!...a_k!}
\end{align*}
\]</span> 然后每个种类中能组成不同环的个数为 <span
class="math inline">\(c_{a_i}\)</span> ，最后再除以 <span
class="math inline">\(k!\)</span> ，因为环之间的排列顺序是无序的。</p>
<p>总结答案为： <span class="math display">\[
\frac{1}{k!}\sum_{a_1+a_2+...+a_k=n}\frac{n!}{a_1!a_2!...a_k!}c_{a_1}c_{a_2}...c_{a_k}
\]</span> 那么发现后面的部分为 <span
class="math inline">\(C(x)^k\)</span>，因此 <span
class="math inline">\(F(x)=\frac{1}{k!}C(x)^k\)</span>。最后询问 <span
class="math inline">\((n,k)\)</span> 的答案是，就能使用生成函数在 <span
class="math inline">\(O(nlogn)\)</span> 的时间内计算出来（计算多项式
<span class="math inline">\(P(x)^k=exp(klnP(x))\)</span>的时间复杂度为
<span class="math inline">\(O(nlogn)\)</span>）</p>
<p><strong>问题 <span class="math inline">\(2\)</span></strong>：计算
<span class="math inline">\(n\)</span>
个元素的置换的个数，且所有环的长度都在一组固定的正整数集合 <span
class="math inline">\(S\)</span> 中。</p>
<p>与上一个问题相同的技巧，但还要加一个条件，就是如果长度 <span
class="math inline">\(i\)</span> 不在 <span
class="math inline">\(S\)</span> 中则令 <span
class="math inline">\(c_i=0\)</span>即可。</p>
<p>这一次我们需要计算 <span
class="math inline">\([x^n]\sum\limits_{k\geq0}\frac{1}{k!}C(x)^k=[x^n]exp(C(x))\)</span>。因为需要遍历所有的
<span class="math inline">\(k\)</span> 并把对应的方案数都加起来。</p>
<p><strong>问题 <span class="math inline">\(3\)</span></strong> ：计算
<span class="math inline">\(n\)</span> 个元素置换中环的期望个数。</p>
<p>为了计算环的期望个数，我们将所有 <span
class="math inline">\(n\)</span> 的排列中的所有环数加起来。让 <span
class="math inline">\(g_n\)</span> 是所有 <span
class="math inline">\(n\)</span> 的排列中的所有环数而 <span
class="math inline">\(G(x)\)</span> 是 <span
class="math inline">\(g\)</span> 的 <span
class="math inline">\(EGF\)</span> 。我们继续使用辅助 <span
class="math inline">\(C\)</span>
生成函数，我们要计算的是：（注意到这里和上面不同的是多乘了一个 <span
class="math inline">\(k\)</span>） <span class="math display">\[
[x^n]G(x)=[x^n]\sum_{k\geq1}\frac{k}{k!}C(x)^k=[x^n]C(x)\sum_{k\geq1}\frac{1}{(k-1)!}C(x)^{k-1}=[x^n]C(x)exp(C(x))
\]</span> 同时，<span
class="math inline">\(C(x)=\sum\limits_{k\geq1}\frac{(k-1)!}{k!}x^k=\sum\limits_{k\geq1}\frac{x^k}{k}=-ln(1-x)\)</span>，因此
<span
class="math inline">\(C(x)exp(C(x))=-\frac{ln(1-x)}{1-x}\)</span>。
那么对于 <span class="math inline">\(n\geq1\)</span> 有 <span
class="math inline">\([x^n](-ln(1-x))=\frac{1}{n}\)</span>，根据 <span
class="math inline">\(OGF\)</span> 的前缀和技巧，乘以 <span
class="math inline">\(\frac{1}{1-x}\)</span>
相当于对系数做前缀和，因此： <span
class="math inline">\([x^n]\frac{ln(1-x)}{1-x}=1+\frac{1}{2}+...+\frac{1}{n}\)</span>，也就是说：<span
class="math inline">\([x^n]G(x)=1+\frac{1}{2}+...+\frac{1}{n}\)</span>，那么最终的答案即为
<span
class="math inline">\(\sum\limits_{n=1}\frac{1}{n}\)</span>，也就是调和级数。</p>
<p>我们再一次见到了指数技巧对于处理小物品的方案数是可行的。</p>
<p><strong>问题 <span class="math inline">\(4\)</span></strong>：将集合
<span class="math inline">\({1,2,...,n}\)</span> 划分成 <span
class="math inline">\(k\)</span> 个不相交子集的方案数是多少？
这个问题称为第二类斯特林数。</p>
<p>我们记答案为 <span class="math inline">\(f(n,k)\)</span>
。解决此题的技巧就是利用多项式（也称单位枚举器）<span
class="math inline">\(D(x)=\sum\limits_{n=1}^\infty\frac{x^n}{n!}\)</span>
。那么 <span class="math inline">\(D(x)^k\)</span> 是什么？我们有 <span
class="math inline">\([x^n]D(x)^k=\sum\limits_{a_1+...+a_k=n,a_i\geq1}\frac{1}{a_1!a_2!...a_k!}\)</span>，因此这个和的意义同之前的解释一样，我们假设我们的子集分别标记
<span class="math inline">\(1\)</span> 到 <span
class="math inline">\(k\)</span>，然后 <span
class="math inline">\(a_i\)</span> 指的是第 <span
class="math inline">\(i\)</span> 个集合的大小并且有 <span
class="math inline">\(\frac{n!}{a_1!a_2!...a_k!}\)</span> 中方案去划分
<span class="math inline">\(k\)</span> 个子集，最后我们还要除以 <span
class="math inline">\(k!\)</span>，因为子集间的顺序是无关的。因此我们最终得到
<span class="math inline">\(k!f(n,k)=n![x^n]D(x)^k\)</span>。</p>
<p>做一下恒等变形，我们就能得到 <span
class="math inline">\(\frac{f(n,k)}{n!}=\frac{[x^n]D(x)^k}{k!}\)</span>，也就是说
<span
class="math inline">\(\sum\limits_{n=0}^\infty\frac{f(n,k)}{n!}x^n=\frac{D(x)^k}{k!}\)</span>
。但这只是关于 <span class="math inline">\(n\)</span> 的 <span
class="math inline">\(EGF\)</span>，我们还需要在最外层再套一层关于 <span
class="math inline">\(k\)</span> 的 <span
class="math inline">\(EGF\)</span> 得到： <span class="math display">\[
\sum_{k=0}^\infty\sum_{n=0}^\infty\frac{f(n,k)}{n!}x^ny^k=\sum_{k=0}^\infty\frac{[D(x)y]^k}{k!}=exp(D(x)y)
\]</span> 注：我们称多项式 <span
class="math inline">\(H(x,y)=\sum\limits_{k=0}^\infty\sum\limits_{n=0}^\infty\frac{f(n,k)}{n!}x^ny^k\)</span>
为手动枚举器。</p>
<p>因此，我们有一个简单记法的等式 <span
class="math inline">\(H(x,y)=exp(D(x)y)\)</span>。由于 <span
class="math inline">\(D(x)=\sum\limits_{n=1}^\infty\frac{x^n}{n!}=e^x-1\)</span>，因此
<span
class="math inline">\(H(x,y)=e^{(e^x-1)y}\)</span>，观察可以发现，当
<span class="math inline">\(y=1\)</span> 时，<span
class="math inline">\(H(x,1)\)</span> 就是 <span
class="math inline">\(Bell\)</span> 数的生成函数
（<strong>为什么？</strong>）</p>
<p>为了计算答案，我们只需要找到 <span
class="math inline">\(n![x^ny^k]H(x,y)=n![x^n]\frac{(e^x-1)^k}{k!}\)</span>，对于这个式子可以使用多项式运算来有效计算它。</p>
<p><strong>图计数问题</strong></p>
<p><strong>问题 <span
class="math inline">\(5\)</span></strong>：总共有多少种 <span
class="math inline">\(n\)</span> 个带标号节点的无向图，其中每个节点度为
<span class="math inline">\(2\)</span> ？</p>
<p>每一个这样的图必须是由不相交的环组成（可以考虑从反证法进行入手证明。）一般情况下，我们考虑对于一个连通分量的生成函数作为切入点。让
<span class="math inline">\(d_n\)</span> 为一个带标记节点的数量为 <span
class="math inline">\(n\)</span> 的一个无向环的方案数而 <span
class="math inline">\(D(x)\)</span> 为 <span
class="math inline">\(d\)</span> 的 <span
class="math inline">\(EGF\)</span>。那么： <span class="math display">\[
D(x)=\sum_{n\geq3}\frac{(n-1)!}{2}\cdot\frac{x^n}{n!}=\frac{1}{2}\sum_{n\geq3}\frac{x^n}{n}=\frac{1}{2}(-ln(1-x)-x-\frac{x^2}{2})
\]</span> （由上文我们得到 <span class="math inline">\(n\)</span>
个元素不同环的数量为 <span
class="math inline">\((n-1)!\)</span>，但是此时的环是有向环，因此转化成无向环的数量还需要再除以
<span class="math inline">\(2\)</span>）</p>
<p>同时我们让 <span class="math inline">\(G(x)\)</span> 是我们答案的
<span class="math inline">\(EGF\)</span> 。使用之前的分析过程，我们发现
<span class="math inline">\(G(x)=exp(D(x))\)</span> 。（对 <span
class="math inline">\(D(x)^k\)</span> 求和即可得到）因此最终的答案为：
<span class="math display">\[
G(x)=exp\bigg(\
ln\bigg(\sqrt{\frac{1}{1-x}}\bigg)-\frac{x}{2}-\frac{x^2}{4}\bigg)=\frac{e^{-\frac{x}{2}-\frac{x^2}{4}}}{\sqrt{1-x}}
\]</span> 那么只要计算出 <span class="math inline">\(x^n\)</span>
的系数就能获得答案。</p>
<p>问题 <span class="math inline">\(6\)</span>：有 <span
class="math inline">\(n\)</span>
个带标号节点的二分图（可能不连通）的个数是多少？</p>
<p>第一眼我们非常想用上面的技巧来解决这个问题。我们可以建立一般的二分图和连通的二分图的数量之间的关系。但是我们能简单的计算出连通二分图的数量吗？不幸的是，很显然无法简单的直接计算出来。</p>
<p>换一种思路，我们去对无向图进行红蓝染色，之后计算染色后二分图（不必连通）的数量。假设将
<span class="math inline">\(k\)</span> 个节点染成红色，将 <span
class="math inline">\(n-k\)</span> 个节点染成蓝色，那么我们就有 <span
class="math inline">\(C_n^k\)</span> 种染色方案和 <span
class="math inline">\(2^{k(n-k)}\)</span> 种连边方案（因为有 <span
class="math inline">\(k(n-k)\)</span> 个可连的边）。因此，<span
class="math inline">\(n\)</span> 个带标号节点的染色二分图数量为 <span
class="math inline">\(\sum\limits_{k\geq0}C_n^k2^{k(n-k)}\)</span>。此时称这个数列为
<span class="math inline">\(a_n\)</span>，并且它的 <span
class="math inline">\(EGF\)</span> 记为 <span
class="math inline">\(A(x)\)</span>。</p>
<p>下一步就是建立带标号节点的染色二分图的数量和连通的带标号节点的染色二分图的数量。令
<span class="math inline">\(b_n\)</span> 为 <span
class="math inline">\(n\)</span>
个连通的带标号节点的染色二分图数量并且它的 <span
class="math inline">\(EGF\)</span> 记为 <span
class="math inline">\(B(x)\)</span> 。那么根据上面同样的方式我们就能得到
<span class="math inline">\(A(x)=exp(B(x))\)</span>，也就是 <span
class="math inline">\(B(x)=ln(A(x))\)</span>。</p>
<p>回到原问题，我们下一步就是计算 <span class="math inline">\(n\)</span>
个带标号节点的连通的二分图的数量，记为 <span
class="math inline">\(c_n\)</span> 且 <span
class="math inline">\(EGF\)</span> 记为 <span
class="math inline">\(C(x)\)</span>。然而这令人意外的简单，因为 <span
class="math inline">\(n\)</span>
个连通的带标号节点的染色二分图将这个图唯一的分成了两个部分（仅仅交换红蓝两个颜色）。因此
<span class="math inline">\(C(x)=\frac{B(x)}{2}\)</span> 。</p>
<p>最后我们令 <span class="math inline">\(d_n\)</span> 为我们答案的
<span class="math inline">\(EGF\)</span>，那么 <span
class="math inline">\(D(x)=exp(C(x))\)</span> 。也就是说： <span
class="math display">\[
D(x)=exp(C(x))=exp\bigg(\frac{B(x)}{2}\bigg)=exp\bigg(\frac{ln(A(x))}{2}\bigg)=\sqrt{A(x)}
\]</span> 问题 <span class="math inline">\(7\)</span> ：考虑一个 <span
class="math inline">\(n\times n\)</span>
的棋盘，棋盘中一些格子是黑色的另一些是白色的。假设我们突然想知道一个数列
<span class="math inline">\(r_k\)</span>，<span
class="math inline">\(r_k\)</span> 代表只在白色格子上放置 <span
class="math inline">\(k\)</span>
个互不攻击车（没有两个车在同一行或同一列，没有车在黑色方格上）的方案数。令
<span class="math inline">\(e_k\)</span> 为放置 <span
class="math inline">\(n\)</span> 个互不攻击的车，而这 <span
class="math inline">\(n\)</span> 个车有恰好 <span
class="math inline">\(k\)</span> 个在白色格子上的方案数。我们可以用
<span class="math inline">\(r_k\)</span> 计算 <span
class="math inline">\(e_k\)</span>吗？</p>
<p>这个技巧就是“至少”这个条件的计数要比“恰好”这个条件的计数更简单。对于一个由白色棋子组成的固定的子集
<span class="math inline">\(S\)</span>，令 <span
class="math inline">\(N(S)\)</span> 指的是放置 <span
class="math inline">\(n\)</span> 个互不攻击的车保证至少 <span
class="math inline">\(S\)</span> 集合的格子上都有车。令 <span
class="math inline">\(n_k=\sum\limits_{|S|=k}N(S)\)</span> 。</p>
<p>我们建立 <span class="math inline">\(n_k\)</span> 和 <span
class="math inline">\(e_k\)</span> 之间的关系。考虑一个大小为 <span
class="math inline">\(t\)</span> 的子集 <span
class="math inline">\(T\)</span> 和一种放置 <span
class="math inline">\(n\)</span>
个互不攻击的车满足他们占据白色的格子正好是集合 <span
class="math inline">\(T\)</span>。<span class="math inline">\(T\)</span>
中每一个大小为 <span class="math inline">\(k\)</span> 的子集都对 <span
class="math inline">\(n_k\)</span> 有贡献。因此，我们得到了一个循环式
<span
class="math inline">\(n_k=\sum\limits_{t\geq0}C_t^ke_t\)</span>。</p>
<p>让我们令 <span class="math inline">\(N(x)\)</span> 和 <span
class="math inline">\(E(x)\)</span> 分别是 <span
class="math inline">\(n_k\)</span> 和 <span
class="math inline">\(e_k\)</span> 的 <span
class="math inline">\(OGF\)</span>。之间我们能导出一个简单的关系。这样的话，我们就有：
<span class="math display">\[
N(x)=\sum_{k\geq0}x^k\sum_{t\geq0}C_t^ke_t=\sum_{t\geq0}e_t\sum_{k\geq0}C_t^kx^k=\sum_{t\geq0}e_t(x+1)^t=E(x+1)
\]</span> 因此，我们有一个简单的式子 <span
class="math inline">\(E(x)=N(x-1)\)</span>。</p>
<p><span class="math inline">\(n_k\)</span> 更加好计算，在我们的问题中
<span class="math inline">\(n_k=r_k(n-k)!\)</span>
。因为我们可以首先选择 <span class="math inline">\(k\)</span>
个在白色格子上的互不攻击的车作为集合 <span
class="math inline">\(S\)</span>，然后放置剩下的 <span
class="math inline">\(n-k\)</span> 个棋子，方案数为 <span
class="math inline">\((n-k)!\)</span> 。因此，我们能得到 <span
class="math inline">\(N(x)=\sum\limits_{k\geq0}r_k(n-1)!x^k\)</span>，进而
<span
class="math inline">\(E(x)=\sum\limits_{k\geq0}r_k(n-k)!(x-1)^k\)</span>
。因此我们能读取 <span class="math inline">\(E(x)\)</span>
的系数作为答案。</p>
<h4
id="使用生成函数证明一些有趣的定理">使用生成函数证明一些有趣的定理</h4>
<p>一个分拆是将 <span class="math inline">\(n\)</span> 分拆成 <span
class="math inline">\(k\)</span>
个元素的多重集合并且集合中的元素加起来等于 <span
class="math inline">\(n\)</span> 。例如，集合 <span
class="math inline">\(\{3,1,1\}\)</span> 是 <span
class="math inline">\(5\)</span> 的一个分拆。注意到集合是无序的。</p>
<p><strong>分拆为奇数元素 = 分拆为互不相同的元素</strong></p>
<p>你可能已经知道分拆 <span class="math inline">\(n\)</span>
为奇数元素的方案数等于分拆 <span class="math inline">\(n\)</span>
为互不相同元素的方案数。那么我们证明更一般性的问题。</p>
<p><strong>问题：</strong>将 <span class="math inline">\(n\)</span>
分拆成元素不能被 <span class="math inline">\(k+1\)</span>
整除的集合的方案数等于将 <span class="math inline">\(n\)</span>
分拆成一个多重集合，满足这个多重集合的最大重数不能超过 <span
class="math inline">\(k\)</span> 的方案数。
（多重集的定义：是集合概念的推广，在多重集中同一个元素可以出现多次
重数的定义：一个元素在多重集里出现的次数称为这个元素在多重集里面的重数）</p>
<p>注意到当 <span class="math inline">\(k=1\)</span>
的时候就是我们的原问题。</p>
<p>固定 <span class="math inline">\(k\)</span> 让 <span
class="math inline">\(A(x)\)</span> 是左侧计数的 <span
class="math inline">\(OGF\)</span>，而 <span
class="math inline">\(B(x)\)</span> 是右侧计数的 <span
class="math inline">\(OGF\)</span>。观察到对于将 <span
class="math inline">\(n\)</span>
分拆成一个多重集合，满足将这个多重集合的最大重数不能超过 <span
class="math inline">\(k\)</span>，我们可以从 <span
class="math inline">\(1\)</span>
开始枚举集合内的元素，并且根据元素的重数卷积生成函数： <span
class="math display">\[
\begin{align*}
B(x)&amp;=\prod_{r\geq1}(1+x^r+x^{2r}+...+x^{kr})=\prod_{r\geq1}\frac{1-x^{r(k+1)}}{1-x^r}\\
&amp;=\prod_{r\geq1}1-x^{r(k+1)}\bigg(\prod_{r\geq1,(k+1)\nmid
r}\frac{1}{1-x^r}\prod_{r\geq1,(k+1)\mid r}\frac{1}{1-x^r}\bigg)\\
&amp;=\prod_{r\geq1}1-x^{r(k+1)}\bigg(\prod_{r\geq1,(k+1)\nmid
r}\frac{1}{1-x^r}\ \prod_{r\geq1}\frac{1}{1-x^{r(k+1)}}\bigg)\\
&amp;=\prod_{r\geq1,(k+1)\nmid r}\frac{1}{1-x^r}\\
&amp;=\prod_{r\geq1,(k+1)\nmid r}(1 + x^r+x^{2r}+...)=A(x)
\end{align*}
\]</span> <strong><span class="math inline">\(Binet&#39; s\)</span>
公式（解决线性递推）</strong></p>
<p>令 <span class="math inline">\(f_n\)</span> 指的是第 <span
class="math inline">\(n\)</span> 个斐波那契数 （<span
class="math inline">\(f_0=0,f_1=1,f_n=f_{n-1}+f_{n-2}\)</span>）。那么<span
class="math inline">\(Binet&#39; s\)</span> 公式就是 <span
class="math inline">\(f_n=\frac{1}{\sqrt{5}}\big[(\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n\big]\)</span>
。</p>
<p>这看起来很随意，但也确实直接来自生成函数。我们知道 <span
class="math inline">\(F(x)=\frac{x}{1-x-x^2}\)</span> 是 <span
class="math inline">\(f\)</span> 的 <span
class="math inline">\(OGF\)</span>，而这次我们所要用到的技巧就是<strong>分式裂项</strong>。我们让
<span class="math inline">\(-\gamma_1\)</span> 和 <span
class="math inline">\(-\gamma_2\)</span> 是方程 <span
class="math inline">\(1-x-x^2=0\)</span> 的两个根（解出来得 <span
class="math inline">\(\gamma_1=\frac{1+\sqrt{5}}{2},\gamma_2=\frac{1-\sqrt{5}}{2}\)</span>）。然后我们写出
<span
class="math inline">\(F(x)=\frac{A}{x+\gamma_1}+\frac{B}{x+\gamma_2}\)</span>，其中
<span class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 是待定系数，通过计算我们可以得到：
<span class="math display">\[
F(x)=\frac{1}{\gamma_1-\gamma_2}\big(\frac{1}{1-\gamma_1x}-\frac{1}{1-\gamma_2x}\big)=\frac{1}{\sqrt{5}}\bigg(\sum_{j\geq0}\gamma_1^jx^j-\sum_{j\geq0}\gamma_2^jx^j\bigg)=\sum_{j\geq0}\frac{1}{\sqrt{5}}(\gamma_1^j-\gamma_2^j)x^j
\]</span> 那么我们就能得到 <span
class="math inline">\(f_n=\frac{1}{\sqrt{5}}(\gamma_1^n-\gamma_2^n)\)</span>，也就是我们提到的
<span class="math inline">\(Binet&#39; s\)</span> 公式。</p>
<p>注意到这个方法对于一般的线性递推公式也适用。</p>
<p><strong>随机排列得到一个没有环的长度是平方数的概率</strong></p>
<p>这个问题看起来非常的随机，但是可以展示生成函数有多么强大。</p>
<p>首先我们假设我们知道的 <span class="math inline">\(n\)</span>
个元素的排列并且环长为 <span class="math inline">\(i\)</span>
的环的数量为 <span class="math inline">\(a_i\)</span>，并满足 <span
class="math inline">\(\sum\limits_{i\geq1}ia_i=n\)</span>
。有多少个排列满足此要求？通过简单的计数（回想一下第一类斯特林数的过程），我们可以得到公式：
<span class="math display">\[
\frac{n!\prod_\limits{i\geq1}((i-1)!)^{a_i}}{\prod_\limits{i\geq1}(i!)^{a_i}\prod\limits_{i\geq1}(a_i!)}=\frac{n!}{\prod_\limits{i\geq1}i^{a_i}\prod\limits_{i\geq1}(a_i!)}
\]</span>
（博客中也给出了提示：先考虑对环进行标记，然后安排每个环中的元素，然后考虑每一个环内的方案数，最后除以一些重复的因子。）</p>
<p>定义序列 <span class="math inline">\(a=(a_1,a_2,...,a_n)\)</span>
称为一个排列的环形。</p>
<p>让 <span class="math inline">\(c(a)\)</span> 为环形为 <span
class="math inline">\(a\)</span> 的排列方案数，令 <span
class="math inline">\(p(a)\)</span> 为得到环形为 <span
class="math inline">\(a\)</span> 的概率，那么 <span
class="math inline">\(c(a)=\frac{n!}{\prod_\limits{i\geq1}i^{a_i}\prod\limits_{i\geq1}(a_i!)},p(a)=\frac{c(a)}{n!}\)</span>
。</p>
<p>现在，我们考虑一种称为无限变量 <span
class="math inline">\(x_1,x_2,...,x_n\)</span> 参数的生成函数： <span
class="math display">\[
C(x,y)=\sum_{n\geq0}\frac{y^n}{n!}\sum_{a_1+2a_2+...=n,a_i\geq0}c(a)x^{a_1}x^{a_2}...
\]</span> 我们已经知道了 <span class="math inline">\(c(a)\)</span>
的公式，因此代入 <span class="math inline">\(c(a)\)</span>
我们就会得到： <span class="math display">\[
C(x,y)=\bigg(\sum_{a_1\geq0}\frac{(yx_1)^{a_1}}{a_1!1^{a_1}}\bigg)\bigg(\sum_{a_2\geq0}\frac{(y^2x_2)^{a_2}}{a_2!2^{a_2}}\bigg)...=exp(yx_1)exp(\frac{y^2x_2}{2})...=exp\bigg(\sum_{i\geq1}\frac{y^ix_i}{i}\bigg)
\]</span> 因此，对于一个固定环形 <span
class="math inline">\(p(a)=[y^nx_1^{a_1}x_2^{a_2}...]exp\big(\sum\limits_{i\geq1}\frac{y^ix_i}{i}\big)\)</span>
。</p>
<p>让我们回到原问题上，称一个环形是一个好环形当且仅当对于所有的完全平方数
<span class="math inline">\(j\)</span> 都有 <span
class="math inline">\(a_j=0\)</span>。我们想计算 <span
class="math inline">\(\lim_\limits{n\to+\infty}\sum_\limits{a\
good}[y^nx_1^{a_1}x_2^{a_2}...]exp\big(\sum\limits_{i\geq1}\frac{y^ix_i}{i}\big)\)</span>
。我们可以对于所有的非完全平方数 <span class="math inline">\(j\)</span>
都代入 <span class="math inline">\(x_j=1\)</span> 来说明我们不关心 <span
class="math inline">\(x_j\)</span>
的指数（同时注意此时对于所有完全平方数 <span
class="math inline">\(j\)</span>，<span
class="math inline">\(a_j=0\)</span>），因此问题就变成了： <span
class="math display">\[
\begin{align*}
\lim_\limits{n\to+\infty}[y^n]exp\bigg(\sum\limits_{i=z^2}\frac{y^ix_i}{i}+\sum\limits_{i\neq
z^2}\frac{y^i}{i}\bigg)
&amp;=\lim_\limits{n\to+\infty}[y^n]exp\bigg(\sum\limits_{i=z^2}\frac{y^i(x_i-1)}{i}+\sum\limits_{i\geq1}\frac{y^i}{i}\bigg)\\
&amp;=\lim_\limits{n\to+\infty}[y^n]exp\bigg(\sum\limits_{i=z^2}\frac{y^i(x_i-1)}{i}-ln(1-y)\bigg)\\
&amp;=\lim_\limits{n\to+\infty}[y^n]\frac{1}{1-y}exp\bigg(\sum\limits_{i=z^2}\frac{y^i(x_i-1)}{i}\bigg)
\end{align*}
\]</span> 令 <span class="math inline">\(A(x)\)</span> 是 <span
class="math inline">\(a_n=[y^n]exp\big(\sum\limits_{i=z^2}\frac{y^i(x_i-1)}{i}\big)\)</span>
的 <span
class="math inline">\(OGF\)</span>，然后根据前缀和技巧，我们的极限就等于
<span
class="math inline">\(\lim\limits_{n\to+\infty}\sum\limits_{i\geq0}a_i\)</span>
。（假设和收敛，实际上确实是收敛的）</p>
<p>直觉上，我们直接代入 <span class="math inline">\(y=1\)</span> 到
<span
class="math inline">\(exp\bigg(\sum\limits_{i=z^2}\frac{y^i(x_i-1)}{i}\bigg)\)</span>，我们想计算常数项
（没有 <span class="math inline">\(x_i\)</span> 的项）并且此时 <span
class="math inline">\(x_i\)</span> 中的 <span
class="math inline">\(i\)</span> 一定是完全平方数，所以我们代入 <span
class="math inline">\(x_i=0\)</span>，得到： <span
class="math display">\[
\lim_\limits{n\to+\infty}[y^n]\frac{1}{1-y}exp\bigg(\sum\limits_{i=z^2}\frac{y^i(x_i-1)}{i}\bigg)=exp\bigg(\sum\limits_{i=z^2}-\frac{1}{i}\bigg)=e^{-\frac{\pi^2}{6}}
\]</span> 这就是我们的答案（回想一下 <span
class="math inline">\(\sum\limits_{i\geq1}\frac{1}{i^2}=\frac{\pi^2}{6}\)</span>）</p>
<h4
id="一些在证明或发明组合等式的丝滑技巧">一些在证明或发明组合等式的丝滑技巧</h4>
<p>这个思想就是宁可直接处理和式，我们不如通过生成函数处理级数更加简单。</p>
<p>计算和式 <span
class="math inline">\(\sum\limits_{k\geq0}C_k^{n-k}\)</span>，其中 <span
class="math inline">\(n\)</span> 是固定的。</p>
<p>假设我们的问题是计算 <span
class="math inline">\(f(n)\)</span>。考虑计算 <span
class="math inline">\(F(x)\)</span> 的思路更简单，这里 <span
class="math inline">\(F(x)=\sum\limits_{n\geq0}f(n)x^n\)</span>。</p>
<p>我们有： <span class="math display">\[
F(x)=\sum_{n\geq0}f(n)x^n=\sum_{n\geq0}\sum_{k\geq0}C_k^{n-k}x^n=\sum_{k\geq0}\sum_{n\geq0}C_k^{n-k}x^n
\]</span>
这个关键的思路就是是的内层和式计算的更见简单。我们已经知道如何计算 <span
class="math inline">\(\sum\limits_{n\geq0}C_k^{n-k}x^{n-k}\)</span>
。因为它和 <span
class="math inline">\(\sum\limits_{r\geq0}C_k^{r}x^{r}\)</span>
一样，唯一的区别是 <span class="math inline">\(r=n-k\)</span> 。</p>
<p>因此，我们进行如下计算： <span class="math display">\[
\sum_{k\geq0}\sum_{n\geq0}C_k^{n-k}x^n=\sum_{k\geq0}x^k\sum\limits_{n\geq0}C_k^{n-k}x^{n-k}=\sum_{k\geq0}(x(1+x))^k=\frac{1}{1-x-x^2}
\]</span> 这个式子十分的眼熟，就是 <span
class="math inline">\(\frac{F(x)}{x}\)</span>，而 <span
class="math inline">\(F(x)\)</span> 实际上就是斐波那契数列的 <span
class="math inline">\(OGF\)</span>。因此 <span
class="math inline">\(\frac{1}{1-x-x^2}=\sum\limits_{n\geq0}f_{n+1}x^n\)</span>，那么我们的
<span class="math inline">\(f(n)=f_{n+1}\)</span> ，就是第 <span
class="math inline">\(n+1\)</span> 个斐波那契数。</p>
<p>还有许多类似的丝滑的技巧，但是我在这里不会去详细解释。一般的，这些技巧在竞赛中也许有用，特别是当你遇到了二重或三重带组合数的和式，然后你还特别想在
<span class="math inline">\(O(n)\)</span>
的时间内算出来。我们将会在下一部分使用这些技巧。</p>
<p>练习：证明范德蒙德卷积，即：<span
class="math inline">\(\sum\limits_{r=0}^kC_m^rC_n^{k-r}=C_{n+m}^{k}\)</span></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E8%AE%BA/" class="category-chain-item">数论</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>生成函数</div>
      <div>http://example.com/2024/01/19/生成函数/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>qionghua</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/01/19/%E5%A4%9A%E9%A1%B9%E5%BC%8F/" title="多项式">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">多项式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/01/15/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/" title="类欧几里得算法">
                        <span class="hidden-mobile">类欧几里得算法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
