<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ABC333</title>
    <link href="/2024/01/19/ABC333/"/>
    <url>/2024/01/19/ABC333/</url>
    
    <content type="html"><![CDATA[<h1 id="abc333">ABC333</h1><h4 id="a.-three-threes">A. Three Threes</h4><p>签到，输出 <span class="math inline">\(n\)</span> 个 <spanclass="math inline">\(n\)</span> 即可</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> lll = __int128;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(false);</span><br>    <span class="hljs-comment">// cin.tie(0);</span><br>    <span class="hljs-comment">// cout.tie(0);</span><br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; n;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="b.-pentagon">B. Pentagon</h4><p>题意：给出两组来自五边形的两个顶点，判断组成的两条线段的长度是否相等。</p><p>思路：</p><p>观察发现，如果组成的两条线段，要么两个顶点相减的绝对值都相等，要么两个顶点相减的绝对值相加等于<span class="math inline">\(5\)</span> 。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> lll = __int128;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(false);</span><br>    <span class="hljs-comment">// cin.tie(0);</span><br>    <span class="hljs-comment">// cout.tie(0);</span><br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        string s1, s2;<br>        cin &gt;&gt; s1 &gt;&gt; s2;<br>        <span class="hljs-type">int</span> tmp1 = <span class="hljs-built_in">abs</span>(s1[<span class="hljs-number">0</span>] - s1[<span class="hljs-number">1</span>]);<br>        <span class="hljs-type">int</span> tmp2 = <span class="hljs-built_in">abs</span>(s2[<span class="hljs-number">0</span>] - s2[<span class="hljs-number">1</span>]);<br>        <span class="hljs-keyword">if</span>(tmp1 == tmp2) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-number">5</span> - tmp1 == tmp2) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="c.-repunit-trio">C. Repunit Trio</h4><p>题意：给定一个序列 <span class="math inline">\(a\)</span>，且序列<span class="math inline">\(a\)</span> 是由 <spanclass="math inline">\(\{1,11,111,...\}\)</span> 组成的，问从序列 <spanclass="math inline">\(a\)</span> 中取三个数组成的和中，第 <spanclass="math inline">\(N\)</span> 小的是哪个数。</p><p>思路：</p><p>由于 <span class="math inline">\(N\)</span> 最多只有 <spanclass="math inline">\(333\)</span> ，假设序列长度为 <spanclass="math inline">\(len\)</span>，那么取三个数组成的和最多就有 <spanclass="math inline">\(len^3\)</span> ，但是其中由于需要去重，当 <spanclass="math inline">\(len=9\)</span> 时，实际只能组成 <spanclass="math inline">\(165\)</span> 个，那么不妨设大一点，令 <spanclass="math inline">\(len=18\)</span>，那么 <spanclass="math inline">\(len^3\)</span> 就会远远大于 <spanclass="math inline">\(333\)</span>，从直觉上讲，一定会找到前 <spanclass="math inline">\(333\)</span> 个以内的数，将组成的数放进 <spanclass="math inline">\(vector\)</span> 中，然后排序去重后直接输出 <spanclass="math inline">\(v[N-1]\)</span> 即可得到答案。（下列代码是赛时使用的 <span class="math inline">\(map\)</span>做法，较为复杂，不建议作为参考。别问，问就是懒得改。）</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> lll = __int128;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br>ll a[<span class="hljs-number">20</span>];<br>map&lt;ll, <span class="hljs-type">int</span>&gt; mp;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(false);</span><br>    <span class="hljs-comment">// cin.tie(0);</span><br>    <span class="hljs-comment">// cout.tie(0);</span><br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        ll tmp = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">18</span>; i ++ )<br>        &#123;<br>            a[i] = tmp;<br>            tmp = tmp * <span class="hljs-number">10</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">18</span>; i ++ )<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">18</span>; j ++ )<br>            &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= <span class="hljs-number">18</span>; k ++ )<br>                &#123;<br>                    ll now = a[i] + a[j] + a[k];<br>                    mp[now] = <span class="hljs-number">1</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [x, y] : mp)<br>        &#123;<br>            cnt ++ ;<br>            <span class="hljs-keyword">if</span>(n == cnt)<br>            &#123;<br>                cout &lt;&lt; x &lt;&lt; endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="d.-erase-leaves">D. Erase Leaves</h4><p>题意：给定一棵树，每次操作只能删除叶节点及叶节点所连的边，问删除节点<span class="math inline">\(1\)</span> 需要多少操作数。</p><p>思路：</p><p>观察得到，将 <span class="math inline">\(1\)</span> 作为根节点，如果<span class="math inline">\(1\)</span>只有一个儿子，那么它肯定能作为叶节点直接删去，否则，就得对它所有子树的个数进行排序，假设<span class="math inline">\(1\)</span> 号点的子树个数为 <spanclass="math inline">\(num\)</span>，那么只需要取前 <spanclass="math inline">\(num-1\)</span>个子树即可，并将取出的子树个数求和再加 <spanclass="math inline">\(1\)</span> （加 <spanclass="math inline">\(1\)</span> 是因为最后还要删除 <spanclass="math inline">\(1\)</span>号点所需要的操作），就是最后所要求的答案。 而求子树的节点个数，使用<span class="math inline">\(dfs\)</span> 即可。</p><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> lll = __int128;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-type">int</span> sz[N];<br>vector&lt;<span class="hljs-type">int</span>&gt; a;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    sz[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v : e[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(v, u);<br>        <span class="hljs-keyword">if</span>(u == <span class="hljs-number">1</span>) a.<span class="hljs-built_in">push_back</span>(sz[v]);<br>        sz[u] += sz[v];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(false);</span><br>    <span class="hljs-comment">// cin.tie(0);</span><br>    <span class="hljs-comment">// cout.tie(0);</span><br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> u, v;<br>            cin &gt;&gt; u &gt;&gt; v;<br>            e[u].<span class="hljs-built_in">push_back</span>(v), e[v].<span class="hljs-built_in">push_back</span>(u);<br>        &#125;<br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(a));<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i ++ ) ans += a[i];<br>        ans ++ ;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="e.-takahashi-quest">E. Takahashi Quest</h4><p>题意：现在有 <span class="math inline">\(N\)</span>个事件，每一个事件 <span class="math inline">\(i\)</span> 由 <spanclass="math inline">\((t_i,x_i)\)</span> 表示，当 <spanclass="math inline">\(t_i=1\)</span> 时，说明当前事件发现了 <spanclass="math inline">\(x_i\)</span> 类型的药水，你可以选择捡或者不捡；当<span class="math inline">\(t_i=2\)</span> 时，说明当前时间发现了 <spanclass="math inline">\(x_i\)</span> 类型的怪，需要 <spanclass="math inline">\(x_i\)</span> 类型的药水，如果没有则闯关失败。问从<span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(N\)</span>的整个过程中，你携带的药水的最大数量的最小化后的值是多少，同时输出你选择药水的方案，如果没有对应方案，输出<span class="math inline">\(-1\)</span> 。</p><p>思路：</p><p>如果正着做，可以将当前药水暂时存进一个数组中，遇到什么怪物将其取出即可，剩下在数组里的药水即为选择不捡的药水，而选择的药水在数组中标记为<span class="math inline">\(0\)</span>即可。如果遇到怪物后没有对应类型的药水，则直接输出 <spanclass="math inline">\(-1\)</span>。</p><p>如果反着做，那么贪心来讲，只要前面没有怪的药水，都可以统统不选，前面有怪的药水，如果前面有同一类型的怪，则可以选择，如果是不同类型的，则不做选择；最后如果有剩下怪物，则输出<span class="math inline">\(-1\)</span> ，否则直接输出答案和方案。</p><p>时间复杂度：<span class="math inline">\(O(n)\)</span> （下列代码为<span class="math inline">\(O(nlogn)\)</span>，<spanclass="math inline">\(map\)</span>可以换成数组替代，同时下列代码采用反着做的形式且较为复杂，不建议参考）</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> lll = __int128;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br><span class="hljs-type">int</span> vis[N];<br>pii p[N];<br><span class="hljs-type">int</span> idx[N];<br>map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mp1, mp2;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(false);</span><br>    <span class="hljs-comment">// cin.tie(0);</span><br>    <span class="hljs-comment">// cout.tie(0);</span><br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <br>        &#123;<br>            cin &gt;&gt; p[i].x &gt;&gt; p[i].y;<br>            <span class="hljs-keyword">if</span>(p[i].x == <span class="hljs-number">1</span>) idx[i] = len ++ ;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; ~i; i -- )<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p[i].x == <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(mp1[p[i].y] != <span class="hljs-number">0</span>) vis[idx[i]] = <span class="hljs-number">1</span>, mp1[p[i].y] -- ; <br>            &#125;<br>            <span class="hljs-keyword">else</span> mp1[p[i].y] ++ ;<br>        &#125;<br>        <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>        &#123;<br>            <span class="hljs-keyword">if</span>(p[i].x == <span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-keyword">if</span>(!vis[idx[i]]) <span class="hljs-keyword">continue</span>;<br>                now ++ ;<br>                ans = <span class="hljs-built_in">max</span>(ans, now);<br>                mp2[p[i].y] ++ ;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(mp2[p[i].y] == <span class="hljs-number">0</span>)<br>            &#123;<br>                flag = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> mp2[p[i].y] -- , now -- ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag)<br>        &#123;<br>            cout &lt;&lt; ans &lt;&lt; endl;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i ++ ) cout &lt;&lt; vis[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>            cout &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span> );<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="f.-bomb-game2">F. Bomb Game2</h4><p>题意：有 <span class="math inline">\(N\)</span> 个人且起初按照 <spanclass="math inline">\(1\sim N\)</span>的顺序进行排列，同时一直重复下述操作，直至只剩下一个人：以 <spanclass="math inline">\(\frac{1}{2}\)</span>的概率删除队头的人，否则将队头的人移到后面去，问 <spanclass="math inline">\(1\sim N\)</span>每个人是剩下的最后一个人的概率，同时对 <spanclass="math inline">\(998244353\)</span> 取模。</p><p>思路：</p><p>由于 <span class="math inline">\(N\)</span> 是 <spanclass="math inline">\(3000\)</span> 水平的，那么就会想到 <spanclass="math inline">\(n^2\)</span> 的概率 <spanclass="math inline">\(\text{DP}\)</span>的做法，由于最后只会有一个人获胜，我们就直接设 <spanclass="math inline">\(dp_{i,j}\)</span> 为 <spanclass="math inline">\(i\)</span> 个人中，第 <spanclass="math inline">\(j\)</span> 个人获胜的概率。</p><p>那么由于有 <span class="math inline">\(\frac{1}{2}\)</span>的概率删除队头的人，那么第 <span class="math inline">\(j\)</span>个人就会前移成第 <span class="math inline">\(j-1\)</span>个人，同时因为删除了一个人 <span class="math inline">\(i\)</span> 变为了<span class="math inline">\(i-1\)</span>，因此此时的状态为 <spanclass="math inline">\(dp_{i-1,j-1}\)</span>；又有<spanclass="math inline">\(\frac{1}{2}\)</span> 的概率将队头的人移到队尾，第<span class="math inline">\(j\)</span> 个人也会前移成第 <spanclass="math inline">\(j-1\)</span> 个人，但 <spanclass="math inline">\(i\)</span> 不变，此时的状态为 <spanclass="math inline">\(dp_{i,j-1}\)</span>，最终，我们得到如下的转移方程：<span class="math display">\[dp[i][j]=\begin{cases}\frac{1}{2}dp[i-1][j-1]+\frac{1}{2}dp[i][j-1]&amp;(j&gt;1)\\\frac{1}{2}dp[i][i]&amp;(j=1)\end{cases}\]</span> 由于当 <span class="math inline">\(j=1\)</span>是，如果删除队头，那么 <span class="math inline">\(j=1\)</span>就没有赢得可能，所以只有被移到队尾才有赢的可能。同时初始状态 <spanclass="math inline">\(dp[1][1]=1\)</span>。</p><p>那么我们转移到后面发现，这个转移方程是成环的一个情况，那么首先我们将<span class="math inline">\(dp[i][1]=\frac{1}{2}dp[i][i]\)</span>取出来，同时对 <span class="math inline">\(dp[i][i]\)</span>进行展开，即： <span class="math display">\[\begin{aligned}dp[i][i]&amp;=\frac{1}{2}dp[i-1][i-1]+\frac{1}{2}dp[i][i-1]\\&amp;=\frac{1}{2}(\frac{1}{2}dp[i-2][i-2]+\frac{1}{2}dp[i-1][i-2])+\frac{1}{2}(\frac{1}{2}dp[i-1][i-2]+dp[i][i-2])\\&amp;=\frac{1}{4}dp[i-2][i-2]+\frac{1}{2}dp[i-1][i-2]+\frac{1}{4}dp[i][i-2]\\&amp;=\frac{1}{8}dp[i-3][i-3]+\frac{3}{8}dp[i-2][i-3]+\frac{3}{8}dp[i-1][i-3]+\frac{1}{8}dp[i][i-3]\\&amp;=\cdots\\&amp;=\sum_{j=0}^{i-1}\frac{C_{i-1}^{j}}{2^{i-1}}dp[i-j][1]\end{aligned}\]</span> 结合 <spanclass="math inline">\(dp[i][1]=\frac{1}{2}dp[i][i]\)</span>，我们就能得到：<span class="math display">\[dp[i][1]=\frac{1}{2^i}\sum_{j=0}^{i-1}(C_{i-1}^{j}\times dp[i-j][1])\]</span> 我们将 <span class="math inline">\(j=0\)</span>的部分移到左边去： <span class="math display">\[\frac{2^i-1}{2^i}dp[i][1]=\frac{1}{2^i}\sum_{j=1}^{i-1}(C_{i-1}^{j}\timesdp[i-j][1])\]</span> 再把分数移到右边去，最终得到： <span class="math display">\[dp[i][1]=\frac{1}{2^i-1}\sum_{j=1}^{i-1}(C_{i-1}^{j}\times dp[i-j][1])\]</span> 通过预处理组合数，我们就能在 <spanclass="math inline">\(O(n^2)\)</span> 的时间复杂度内处理好所有 <spanclass="math inline">\(dp[i][1]\)</span>，那么 <spanclass="math inline">\(j&gt;1\)</span> 的情况就不会出现环的状况，也能通过<span class="math inline">\(O(n^2)\)</span>的时间复杂度处理完成，那么最后根据定义，依次输出 <spanclass="math inline">\(dp[n][i]\)</span> 即可。</p><p>时间复杂度：<span class="math inline">\(O(n^2)\)</span></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> lll = __int128;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br><span class="hljs-type">int</span> dp[<span class="hljs-number">3005</span>][<span class="hljs-number">3005</span>];<br><span class="hljs-type">int</span> c[<span class="hljs-number">3005</span>][<span class="hljs-number">3005</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qp</span><span class="hljs-params">(<span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(p)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p &amp; <span class="hljs-number">1</span>) ans = <span class="hljs-number">1ll</span> * ans * b % MOD;<br>        b = <span class="hljs-number">1ll</span> * b * b % MOD;<br>        p &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qp</span>(x, MOD - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">3000</span>; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j ++ )<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) c[i][j] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> c[i][j] = (c[i - <span class="hljs-number">1</span>][j] + c[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]) % MOD;<br>        &#125;<br>    &#125;<br>    dp[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(false);</span><br>    <span class="hljs-comment">// cin.tie(0);</span><br>    <span class="hljs-comment">// cout.tie(0);</span><br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin &gt;&gt; n;<br>        <span class="hljs-built_in">init</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> tmp = <span class="hljs-built_in">inv</span>(<span class="hljs-built_in">qp</span>(<span class="hljs-number">2</span>, i) - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++ )<br>            &#123;<br>                dp[i][<span class="hljs-number">1</span>] = (dp[i][<span class="hljs-number">1</span>] + <span class="hljs-number">1ll</span> * c[i - <span class="hljs-number">1</span>][j] * dp[i - j][<span class="hljs-number">1</span>] % MOD) % MOD;<br>            &#125;<br>            dp[i][<span class="hljs-number">1</span>] = <span class="hljs-number">1ll</span> * dp[i][<span class="hljs-number">1</span>] * tmp % MOD;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= i; j ++ )<br>            &#123;<br>                dp[i][j] = (<span class="hljs-number">1ll</span> * <span class="hljs-built_in">inv</span>(<span class="hljs-number">2</span>) * dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] % MOD + <span class="hljs-number">1ll</span> * <span class="hljs-built_in">inv</span>(<span class="hljs-number">2</span>) * dp[i][j - <span class="hljs-number">1</span>] % MOD) % MOD;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cout &lt;&lt; dp[n][i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="g.-nearest-fraction">G. Nearest Fraction</h4><p>题意：给定一个正实数 <span class="math inline">\(r\)</span>和一个正整数 <span class="math inline">\(N\)</span>，求一个整数对 <spanclass="math inline">\((p,q)\)</span>（<span class="math inline">\(0\leqp\leq q\leq N\)</span>），使得其满足 <spanclass="math inline">\(gcd(p,q)=1\)</span> 且 <spanclass="math inline">\(|r-\frac{p}{q}|\)</span>的值是最小的，如果有多组整数对，输出分数表示 <spanclass="math inline">\(\frac{p}{q}\)</span> 最小的那一组。</p><p>思路：</p><p>算是最佳有理数逼近的定义，因此需要使用到 <spanclass="math inline">\(\text{Stern-Brocot}\)</span>树。（以下简要说明，详情参考博客）</p><p><span class="math inline">\(\text{Stern-Brocot}\)</span> 树：</p><p>一种较为优雅的维护分数的数据结构，从简单的两个分数开始 <spanclass="math inline">\(\frac{0}{1},\frac{1}{0}\)</span>，每次在相邻的两个分数<span class="math inline">\(\frac{a}{b},\frac{c}{d}\)</span>中间插入一个分数 <spanclass="math inline">\(\frac{a+c}{b+d}\)</span>，这样就完成了一次迭代，得到下一个序列，变成如下形式：<span class="math display">\[\begin{align}\frac{0}{1},&amp;\frac{1}{1},\frac{1}{0} \\\frac{0}{1},\frac{1}{2},&amp;\frac{1}{1},\frac{2}{1},\frac{1}{0} \\\frac{0}{1},\frac{1}{3},\frac{1}{2},\frac{2}{3},&amp;\frac{1}{1},\frac{3}{2},\frac{2}{1},\frac{3}{1},\frac{1}{0}\end{align}\]</span> 转化成树的样子，即为：</p><figure><img src="/images/stern-brocot.png"alt="Stern-Brocot树（来源：OI-Wiki）" /><figcaptionaria-hidden="true">Stern-Brocot树（来源：OI-Wiki）</figcaption></figure><p>观察到这棵树的中序遍历即为上述所说的序列，且为升序，并且整棵树的分数的分子分母的<span class="math inline">\(gcd\)</span> 均等于 <spanclass="math inline">\(1\)</span> 。</p><p>有了这个数据结构，我们再思考如何利用这棵树做题目，首先从树转化成一维序列来看，由于所有分数的分子分母的<span class="math inline">\(gcd\)</span> 均等于 <spanclass="math inline">\(1\)</span> ，已经满足了 $gcd(p,q) $的条件，因此我们只需要满足后续逼近 <spanclass="math inline">\(r\)</span> 的操作即可。因此对于这个一维序列，我们很容易的想到用二分来找到最大的小于等于 <spanclass="math inline">\(r\)</span> 的分数 <spanclass="math inline">\(x\)</span> 和最小的大于等于 <spanclass="math inline">\(r\)</span> de 分数 <spanclass="math inline">\(y\)</span>，那么只需要比较 <spanclass="math inline">\(r-x\)</span> 和 <spanclass="math inline">\(y-r\)</span> 的大小，看需要输出的是 <spanclass="math inline">\(x\)</span> 还是 <spanclass="math inline">\(y\)</span> 即可。</p><p>那由于这个一维序列本身的长度就在 <spanclass="math inline">\(O(n^2)\)</span>级别，所以构造这个一维序列就完全不切实际，因此需要借助 <spanclass="math inline">\(\text{Stern-Brocot}\)</span>树在树上进行二分：如果当前根节点小于 <spanclass="math inline">\(r\)</span>，则进入左儿子，否则进入右儿子，不断逼近 <spanclass="math inline">\(r\)</span> 来取得 <spanclass="math inline">\(x\)</span> 和 <spanclass="math inline">\(y\)</span> :</p><figure><img src="/images/ABC333G.png" alt="ABC333G（来源：Atcoder官方题解）" /><figcaptionaria-hidden="true">ABC333G（来源：Atcoder官方题解）</figcaption></figure><p>但是这样理论上会被卡到 <span class="math inline">\(O(n)\)</span>级别，即给定的实数 <span class="math inline">\(r\)</span>太小一直往左走，因此需要进行优化。那么根据一直往左走的思路，我们会推断出在进行二分的过程中，某些路径会长时间朝一个方向走，因此可以采取树上倍增的方式进行优化，即用<span class="math inline">\(logn\)</span>的复杂度直接跳到找一个方向走的终点位置。</p><p>如何倍增：</p><p>由于整棵树的构成是通过这个操作生成的：每次在相邻的两个分数 <spanclass="math inline">\(\frac{a}{b},\frac{c}{d}\)</span> 中间插入一个分数<span class="math inline">\(\frac{a+c}{b+d}\)</span>，那么如果 <spanclass="math inline">\(\frac{a}{b}&lt;r&lt;\frac{a+c}{b+d}\)</span>，那么会继续插一个分数 <spanclass="math inline">\(\frac{2a+c}{2b+d}\)</span>，如果 <spanclass="math inline">\(\frac{a}{b}&lt;r&lt;\frac{2a+c}{2b+d}\)</span>，那么就有会插一个分数 <spanclass="math inline">\(\frac{3a+c}{3b+d}\)</span>，而同时这个过程也是一直往左走的，如果一次次做必然会达到<span class="math inline">\(O(n)\)</span> 的复杂度。但我们发现向左走的过程一定会遇到一个 <spanclass="math inline">\(k\)</span> 使得插入一个分数后 <spanclass="math inline">\(\frac{ka+c}{kb+d}\)</span>就会停下来，我们在树上倍增的过程就是对这个 <spanclass="math inline">\(k\)</span>转化成二进制表示的过程，因此复杂度就优化到 <spanclass="math inline">\(O(logn)\)</span>，向右走同理。</p><p>由于初始 <span class="math inline">\(0&lt;r&lt;1\)</span>，因此 <spanclass="math inline">\(\text{Stern-Brocot}\)</span>树的初始区间就可以设成 <spanclass="math inline">\(\frac{0}{1},\frac{1}{1}\)</span>。同时由于 <spanclass="math inline">\(N\)</span> 是 <spanclass="math inline">\(1e10\)</span> 级别，大概有 <spanclass="math inline">\(34\)</span> 位，因此倍增的时候按照 <spanclass="math inline">\(34\)</span>位进行倍增，同时分数比较的时候会使用两数相乘的方式，达到 <spanclass="math inline">\(1e20\)</span> 级别，<spanclass="math inline">\(\text{long long}\)</span> 已经存不下了，需要使用<span class="math inline">\(\text{int128}\)</span>。</p><p>而 <span class="math inline">\(r\)</span> 最多只有 <spanclass="math inline">\(18\)</span> 个小数位，并且需要将 <spanclass="math inline">\(r\)</span> 转化成分数形式，因此用字符串读入 <spanclass="math inline">\(r\)</span>，然后将小数点后数转化成数即可，并且转化成分数形式后要转化成最简形式即分子分母的<span class="math inline">\(gcd=1\)</span>，因为存在答案本身就是 <spanclass="math inline">\(r\)</span> 的情况。</p><p>时间复杂度：<span class="math inline">\(O(log^2n)\)</span></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> i128 = __int128;<br><span class="hljs-keyword">using</span> ui64 = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br><span class="hljs-keyword">using</span> frac = pair&lt;i128, i128&gt;;<br>frac ans1, ans2;<br>i64 n;<br><br><span class="hljs-function">i128 <span class="hljs-title">gcd</span><span class="hljs-params">(i128 a, i128 b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> b ? <span class="hljs-built_in">gcd</span>(b, a % b) : a;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &gt; (<span class="hljs-type">const</span> frac a, <span class="hljs-type">const</span> frac b)<br>&#123;<br>    <span class="hljs-keyword">return</span> a.x * b.y &gt; a.y * b.x;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> == (<span class="hljs-type">const</span> frac a, <span class="hljs-type">const</span> frac b)<br>&#123;<br>    <span class="hljs-keyword">return</span> a.x * b.y == a.y * b.x;<br>&#125;<br><br><span class="hljs-comment">// a / b + c / d = (a * d + b * c) / b * d</span><br>frac <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> frac a, <span class="hljs-type">const</span> frac b)<br>&#123;<br>    frac tmp = &#123;a.x * b.y + a.y * b.x, a.y * b.y&#125;;<br>    i128 g = <span class="hljs-built_in">gcd</span>(tmp.x, tmp.y);<br>    tmp.x /= g, tmp.y /= g;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-comment">// (a / b) * c = (a * c) / b</span><br>frac <span class="hljs-keyword">operator</span> * (<span class="hljs-type">const</span> frac a, <span class="hljs-type">const</span> i128 b)<br>&#123;<br>    frac tmp = &#123;a.x * b, a.y&#125;;<br>    i128 g = <span class="hljs-built_in">gcd</span>(tmp.x, tmp.y);<br>    tmp.x /= g, tmp.y /= g;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(frac left, frac right, frac r)</span></span><br><span class="hljs-function"></span>&#123;<br>    frac tmp1, tmp2;<br>    tmp1 = right;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">33</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        tmp2 = &#123;tmp1.x + (left.x &lt;&lt; i), tmp1.y + (left.y &lt;&lt; i)&#125;;<br>        <span class="hljs-keyword">if</span>(tmp2.y &gt; n) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(tmp2 == r) <br>        &#123;<br>            ans1 = ans2 = r;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(tmp2 &gt; r) tmp1 = tmp2;<br>    &#125;<br>    right = tmp1;<br>    tmp1 = left;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">33</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        tmp2 = &#123;tmp1.x + (right.x &lt;&lt; i), tmp1.y + (right.y &lt;&lt; i)&#125;;<br>        <span class="hljs-keyword">if</span>(tmp2.y &gt; n) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(tmp2 == r)<br>        &#123;<br>            ans1 = ans2 = r;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r &gt; tmp2) tmp1 = tmp2; <br>    &#125;<br>    left = tmp1;<br>    ans1 = left, ans2 = right;<br>    frac tmp = &#123;left.x + right.x, left.y + right.y&#125;;<br>    <span class="hljs-keyword">if</span>(tmp.y &lt;= n) <span class="hljs-built_in">solve</span>(left, right, r);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(false);</span><br>    <span class="hljs-comment">// cin.tie(0);</span><br>    <span class="hljs-comment">// cout.tie(0);</span><br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        string s;<br>        cin &gt;&gt; s;<br>        cin &gt;&gt; n;<br>        frac r = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> tmp = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            r.x = r.x * <span class="hljs-number">10</span> + tmp;<br>            r.y *= <span class="hljs-number">10</span>;<br>        &#125;<br>        i128 g = <span class="hljs-built_in">gcd</span>(r.x, r.y);<br>        r.x /= g, r.y /= g;<br>        frac left = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;, right = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;;<br>        ans1 = left, ans2 = right;<br>        <span class="hljs-built_in">solve</span>(left, right, r);<br>        <span class="hljs-comment">// r - ans1 &gt; ans2 - r =&gt; 2 * r &gt; ans1 + ans2</span><br>        i64 p, q;<br>        <span class="hljs-keyword">if</span>(r * <span class="hljs-number">2</span> &gt; ans1 + ans2) p = ans2.x, q = ans2.y;<br>        <span class="hljs-keyword">else</span> p = ans1.x, q = ans1.y;<br>        cout &lt;&lt; p &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; q &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AtCoder Beginner Contest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多项式</title>
    <link href="/2024/01/19/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    <url>/2024/01/19/%E5%A4%9A%E9%A1%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="多项式">多项式</h1><h4 id="多项式基本概述">多项式基本概述</h4><h6 id="多项式的基础概念">多项式的基础概念</h6><p>多项式：对于求和是 <span class="math inline">\(\suma_nx^n\)</span>，如果是有限项相加，称为多项式，记作 <spanclass="math inline">\(f(x)=\sum\limits_{n=0}^ma_nx^n\)</span>。</p><p>（多项式的本质就是一个满足一些运算性质的环）</p><p>对于一般环 <span class="math inline">\(R\)</span>，定义 <spanclass="math inline">\(R\)</span> 上的多项式环 <spanclass="math inline">\(R[x]\)</span>，每个元素 <spanclass="math inline">\(f\)</span> 称为 <spanclass="math inline">\(R\)</span> 上的多项式，可表示为： <spanclass="math display">\[f=\langle f_0,f_1,...,f_n\rangle\quad(f_0,f_1,...,f_n\in R)\]</span> 一个多项式可以表示为一个有限长的数组 <spanclass="math inline">\((f_0,f_1,...f_n)\)</span> 。或者一个只有有限项非零的无限长数组 <spanclass="math inline">\((f_0,f_1,...,f_n,0,0,0,...)\)</span> 。多项式的零点个数是有限的，非多项式的零点个数可以是无穷多个，例如：<spanclass="math inline">\(sin\alpha\)</span>是一个无穷多项展开的展开式，<spanclass="math inline">\(sin\alpha\)</span> 的展开式不是一个多项式。</p><p>系数表示法：一个 <span class="math inline">\(n\)</span> 次多项式<span class="math inline">\(F(x)\)</span> 可以表示为如下形式： <spanclass="math display">\[F(x)=f_0+f_1x+f_2x^2+...+f_nx^n=\sum_{i=0}^nf_ix^i\]</span> 点值表示法：将 <span class="math inline">\(n\)</span>个互不相同的 <span class="math inline">\(x\)</span> 带入多项式，得到<span class="math inline">\(n\)</span> 个对应的 <spanclass="math inline">\(y\)</span> 值，则该多项式被这 <spanclass="math inline">\(n\)</span> 组 <spanclass="math inline">\((x,y)\)</span> 唯一确定。</p><p>定理：一个 <span class="math inline">\(n-1\)</span> 次多项式再 <spanclass="math inline">\(n\)</span> 个不同点的取值唯一确定了该多项式，其中<span class="math inline">\(y_i=\sum\limits_{j=0}^{n-1}a_jx_i^j\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成函数</title>
    <link href="/2024/01/19/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    <url>/2024/01/19/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="生成函数">生成函数</h1><p>参考资料：</p><p><ahref="https://blog.csdn.net/jiahonghao2002/article/details/126089862">多项式与生成函数教程合集_x+2y+3z=1000生成函数-CSDN博客</a></p><p>zscoder博客中在算法竞赛中的生成函数（第一部分）：<ahref="https://codeforces.com/blog/entry/77468">https://codeforces.com/blog/entry/77468</a></p><p>zscoder博客中在算法竞赛中的生成函数（第二部分）：<ahref="https://codeforces.com/blog/entry/77551">https://codeforces.com/blog/entry/77551</a></p><p><strong>什么是生成函数</strong></p><p>我们现在有一个数列 <spanclass="math inline">\(a_0,a_1,a_2...\)</span>。我们通过构建数列项和多项式中项的系数关系将数列 <spanclass="math inline">\(a\)</span> 和多项式 <spanclass="math inline">\(A\)</span> 关联起来。</p><p>一般来说，对于一个数列 <spanclass="math inline">\(\{a_i\}_{i=0}^{\infty}\)</span>，我们定义这个数列的<strong>一般生成函数（<spanclass="math inline">\(OGF\)</span>）</strong>为 <spanclass="math inline">\(A(x)=\sum\limits_{i=0}^{\infty}a_ix^i\)</span>。</p><p>举一个简单的例子，考虑斐波那契数列 <spanclass="math inline">\(f\)</span> 为 <spanclass="math inline">\(1,1,2,3,5,8,...\ \)</span>。那么这个数列的 <spanclass="math inline">\(OGF\)</span> 为 <spanclass="math inline">\(F(x)=0+x+x^2+2x^3+3x^4+5x^5+8x^6+...\\)</span>。</p><p>你可以想象是将数列中的每一项（可能是无限多项）按序放入多项式中的每一项的系数中。通过把多项式中每一项都加起来，就会得到一个系数为数列中的每一项构成的“无穷多项式”。构建生成函数的好处就是可以通过生成函数来发现一些数列的惊人性质。</p><p>实际上有很多种的生成函数，例如指数生成函数（<spanclass="math inline">\(EGF\)</span>）和狄利克雷生成函数。在后面都会一一介绍。</p><p>最后为了方便我们引入一个符号：对于一个级数 <spanclass="math inline">\(A(x)=\sum\limits_{n \geq0}a_nx^n\)</span> ，我们记<span class="math inline">\([x^n]A(x)=a_n\)</span> （即 <spanclass="math inline">\(A\)</span> 中 <spanclass="math inline">\(x^n\)</span> 的系数）。</p><p><strong><spanclass="math inline">\(OGF\)</span>的一些简单例子</strong></p><p>我们令数列 <span class="math inline">\(a\)</span> 为 <spanclass="math inline">\(1,1,1,...\)</span>，那么根据上述的定义，数列 <spanclass="math inline">\(a\)</span> 的 <spanclass="math inline">\(OGF\)</span> 就是 <spanclass="math inline">\(A(x)=1+x+x^2+x^3+...\)</span>，观察其实可以发现，<span class="math inline">\(A(x)\)</span> 实际上是一个公比为 <spanclass="math inline">\(x\)</span>的几何级数，也就是说根据等比数列求和公式可以得到 <spanclass="math inline">\(A(x) = \frac{1}{1-x}\)</span>。</p><p>注意：我们并不关系级数的敛散性（例如上述级数在 <spanclass="math inline">\(|x|&lt;1\)</span>是否成立），这取决于你使用级数要做什么事情。在生成函数和大多数情况下，我们将级数视为形式幂级数，我们不需要关心形式幂级数的敛散性问题。但是这并不意味着能随意将参数<span class="math inline">\(x\)</span>带入任意常数，如果确实需要替换值，那么就需要考虑敛散性问题，只有级数收敛才能带入值到<span class="math inline">\(x\)</span> 中。</p><p>我们也可以利用一些代数式的方式和技巧来化简生成函数式，下面是一些典型的例子。</p><p><strong>斐波那契数列的普通生成函数</strong></p><p>在上面介绍生成函数时，我们也提及了斐波那契数列 <spanclass="math inline">\(f\)</span>，现在我们就需要计算该数列的封闭形式。</p><p>考虑数列 <span class="math inline">\(f_n\)</span> 定义为 <spanclass="math inline">\(f_0=0,f_1=1\)</span> 并且对于 <spanclass="math inline">\(n&gt;2\)</span>有 <spanclass="math inline">\(f_n=f_{n-1}+f_{n-2}\)</span> ，计算 <spanclass="math inline">\(f_n\)</span> 的生成函数的封闭形式。</p><p>首先为了凑出多项式的形式，最简单的方法就是等式两边同时乘以 <spanclass="math inline">\(x^n\)</span> ，最终得到 <spanclass="math display">\[f_nx^n=f_{n-1}x^n+f_{n-2}x^n\]</span> 接下来，我们对两边同时求和得到： <span class="math display">\[\sum_{n=2}^{\infty}f_nx^n=x\sum_{n=2}^{\infty}f_{n-1}x^{n-1}+x^2\sum_{n=2}^{\infty}f_{n-2}x^{n-2}\]</span> 根据定义，我们知道： <span class="math display">\[F(x)=\sum_{n=0}^{\infty}f_nx^n\]</span> 那么和式部分就能化简成以下形式： <span class="math display">\[\begin{align*}&amp;F(x)-f_0-f_1x=x(F(x)-f_0)+x^2F(x)\\\Rightarrow &amp;F(x)-x=xF(x)+x^2F(x)\\\Rightarrow&amp;F(x)(1-x-x^2)=x\\\Rightarrow&amp;F(x)=\frac{x}{1-x-x^2}\end{align*}\]</span> 那么最终我们就得到了斐波那契数列的生成函数的封闭形式</p><p><strong><spanclass="math inline">\(Catalan\)</span>数列的普通生成函数</strong></p><p>卡特兰数时组合数学中一个常出现于各种计数问题的数列。 卡特兰数 <spanclass="math inline">\(C_n\)</span> 满足以下递推关系：</p><ol type="1"><li><spanclass="math inline">\(C_{n+1}=C_0C_n+C_1C_{n-1}+...+C_nC_0\)</span></li><li><spanclass="math inline">\((n-3)C_n=\frac{n}{2}(C_3C_{n-1}+C_4C_{n-2}+C_5C_{n-3}+...+C_{n-2}C_4+C_{n-1}C_3)\)</span></li></ol><p>考虑 <span class="math inline">\(Catalan\)</span> 数列 <spanclass="math inline">\(c_n\)</span> 定义为 <spanclass="math inline">\(c_0=1\)</span> 并且对于 <spanclass="math inline">\(n&gt;0\)</span> 都有 <spanclass="math inline">\(c_{n+1}=\sum\limits_{i=0}^nc_ic_{n-i}\)</span>，计算其生成函数的封闭形式。</p><p>那么根据斐波那契数列一样的思路，我们对等式两边同时乘以 <spanclass="math inline">\(x^n\)</span> 并同时求和，得到： <spanclass="math display">\[\sum_{n=0}^{\infty}c_{n+1}x^{n+1}=\sum_{n=0}^{\infty}\sum_{i=0}^nc_ic_{n-i}x^{n+1}\]</span> 我们对等式右边采取这样的拆分形式： <spanclass="math display">\[\sum_{n=0}^{\infty}\sum_{i=0}^nc_ic_{n-i}x^{n+1}=x\sum_{n=0}^{\infty}\sum_{i=0}^nc_ic_{n-i}x^{n}=x\sum_{n=0}^{\infty}\sum_{i=0}^n\(c_ix^i)\times (c_{n-i}x^{n-i})\]</span> 那么 <span class="math inline">\((c_ix^i)\times(c_{n-i}x^{n-i})\)</span> 的形式比较让我们容易联想到使用 <spanclass="math inline">\(C(x)^2\)</span> 的方式来进行解决，我们将 <spanclass="math inline">\(C(x)^2\)</span> 展开： <spanclass="math display">\[C(x)^2=(c_0+c_1x+c_2x^2+...)(c_0+c_1x+c_2x^2+...)\]</span> 观察可以发现，在第一个括号选取 <spanclass="math inline">\(x^i\)</span> 和在第二个括号选取 <spanclass="math inline">\(x^{n-i}\)</span>，那么就能得到 <spanclass="math inline">\(x^n\)</span> 的系数，也就是说，在 <spanclass="math inline">\(C(x)^2\)</span> 中，<spanclass="math inline">\(x^n\)</span> 项的系数就是 <spanclass="math inline">\(\sum\limits_{i=0}^nc_ic_{n-i}\)</span>。</p><p>得到了这一点，我们就能将原式转化成： <span class="math display">\[C(x)-c_0=xC(x)^2\]</span> 同时 <spanclass="math inline">\(c_0=1\)</span>，原式就转化为： <spanclass="math display">\[xC(x)^2-C(x)+1=0\]</span> 很明显，这就是一个一元二次方程，最终解得： <spanclass="math display">\[C(x) = \frac{1\pm\sqrt{1-4x}}{2x}\]</span> 虽然我们最终得到了 <spanclass="math inline">\(C(x)\)</span>，但是问题也随之而来，分子中的符号应该是取正还是取负。首先我们定义的<span class="math inline">\(Catalan\)</span> 数列的第一项 <spanclass="math inline">\(c_0=1\)</span>，也就是说级数应该在 <spanclass="math inline">\(x=0\)</span> 处收敛至 <spanclass="math inline">\(1\)</span> 才对，然后观察正负号在 <spanclass="math inline">\(x=0\)</span> 处的敛散性。</p><p>当分子中的符号取正号时，当 <spanclass="math inline">\(x\rightarrow0\)</span> 时，分子 <spanclass="math inline">\(\rightarrow2\)</span> 而分母 <spanclass="math inline">\(\rightarrow0\)</span> ，也就是说此时级数在 <spanclass="math inline">\(x\rightarrow0\)</span> 处发散。当分子中的符号取负号时，当 <spanclass="math inline">\(x\rightarrow0\)</span> 时，分子 <spanclass="math inline">\(\rightarrow0\)</span> 并且分母 <spanclass="math inline">\(\rightarrow0\)</span>，那根据洛必达法则就很很明显的知道这个级数在<span class="math inline">\(x=0\)</span> 处收敛至 <spanclass="math inline">\(1\)</span>。</p><p>因此最终得到： <span class="math display">\[C(x) = \frac{1-\sqrt{1-4x}}{2x}\]</span>可以尝试寻找一些经典数列，并计算其生成函数的封闭形式，这对形成看到函数递归式就能想到生成函数的直觉有所帮助。</p><h4 id="多变量参数的ogf">多变量参数的<spanclass="math inline">\(OGF\)</span></h4><p>我们不能将自己局限在一个变量上，考虑多变量参数的 <spanclass="math inline">\(OGF\)</span>，下面我们会举一些例子。</p><p><strong>二项式系数 <spanclass="math inline">\(OGF\)</span></strong></p><p>二项式系数 <span class="math inline">\(b(n,k)=C_n^k\)</span>被定义为对于 <span class="math inline">\(n\geq0,\b(n,0)=1\)</span>，对于 <span class="math inline">\(n\geq1,\b(0,n)=0\)</span> 并且对于 <span class="math inline">\(n,k\geq1,\b(n,k)=b(n-1,k)+b(n-1,k-1)\)</span>。计算 <spanclass="math inline">\(b(n,k)\)</span> 的生成函数的封闭形式。</p><p>我们定义 <span class="math inline">\(B(x,y)\)</span> 的展开形式为<spanclass="math inline">\(\sum\limits_{n\geq0}\sum\limits_{k\geq0}b(n,k)x^ny^k\)</span>。那么我们根据之前的策略，得到：<span class="math display">\[\sum\limits_{n\geq1}\sum\limits_{k\geq1}b(n,k)x^ny^k=x\sum\limits_{n\geq1}\sum\limits_{k\geq1}b(n-1,k)x^{n-1}y^k+xy\sum\limits_{n\geq1}\sum\limits_{k\geq1}b(n-1,k-1)x^{n-1}y^{k-1}\]</span> 化简得到： <span class="math display">\[\begin{align*}&amp;B(x,y)-\sum_{n\geq0}x^n=x(B(x,y)-\sum_{n\geq0}x^n)+xyB(x,y)\\\Rightarrow&amp;B(x,y)-\frac{1}{1-x}=xB(x,y)-\frac{x}{1-x}+xyB(x,y)\\\Rightarrow&amp;B(x,y)-xB(x,y)-xyB(x,y)=1\\\Rightarrow&amp;B(x,y)=\frac{1}{1-x-xy}\end{align*}\]</span> 最终得到二项式系数 <span class="math inline">\(OGF\)</span>为：<span class="math inline">\(B(x,y)=\frac{1}{1-x-xy}\)</span></p><p>我们可以利用得到的二项式系数 <span class="math inline">\(OGF\)</span>来推导出很多有趣的一元变量参数的 <spanclass="math inline">\(OGF\)</span>。例如，我们将 <spanclass="math inline">\(B(x,y)\)</span> 看做是关于 <spanclass="math inline">\(x\)</span> 的幂级数，将 <spanclass="math inline">\(y\)</span> 视为常量： <spanclass="math display">\[B(x,y)=\frac{1}{1-x-xy}=\frac{1}{1-(y+1)x}\]</span> 此时我们将 <span class="math inline">\((y+1)x\)</span>视为一个整体，那么原式就会被我们转化为： <span class="math display">\[B(x,y)=\sum_{k=0}^{\infty}\ ((y+1)x)^k=\sum_{k=0}^{\infty}(y+1)^kx^k\]</span> 此时由于 <span class="math inline">\(y\)</span>被视为常量，那么我们就会得到 <spanclass="math inline">\([x^n]B(x,y)=(y+1)^n\)</span>。同时根据定义，<spanclass="math inline">\([x^n]B(x,y)=\sum\limits_{k=0}^{\infty}b(n,k)y^k\)</span>，那么<spanclass="math inline">\(\sum\limits_{k=0}^{\infty}b(n,k)y^k=(y+1)^n\)</span>。这时候我们就发现，这不就和<span class="math inline">\((y+1)^n\)</span>二项式展开的结果一模一样。</p><p>如果我们将 <span class="math inline">\(B(x,y)\)</span> 看做是关于<span class="math inline">\(y\)</span> 的幂级数呢？，那么就变成了：<span class="math display">\[B(x,y)=\frac{1}{1-x-xy}=\frac{\frac{1}{1-x}}{1-\frac{x}{1-x}y}=\frac{1}{1-x}\sum_{k=0}^{\infty}(\frac{x}{1-x})^ky^k=\sum_{k=0}^{\infty}\frac{x^k}{(1-x)^{k+1}}y^k\]</span> 同样的我们也能得到 <spanclass="math inline">\([y^k]B(x,y)=\frac{x^k}{(1-x)^{k+1}}\)</span>，那么<spanclass="math inline">\(\sum\limits_{n=0}^{\infty}b(n,k)x^n=\frac{x^k}{(1-x)^{k+1}}\)</span>，此时我们就得到了<span class="math inline">\(\frac{1}{(1-x)^{k+1}}\)</span>的二项式展开结果。</p><p>根据上述结果我们可以得到 <spanclass="math inline">\([x^{n-k}]\frac{1}{(1-x)^{k+1}}=C_n^k\)</span>，那么进行恒等变形我们就可以得到<spanclass="math inline">\([x^n]\frac{1}{(1-x)^{k}}=C_{n+k-1}^{k-1}\)</span>。</p><p>而这个等式在我们处理二项式系数求和的时候并且 <spanclass="math inline">\(k\)</span> 是固定而 <spanclass="math inline">\(n\)</span> 是变量的情况下是非常有用的。</p><h4 id="指数生成函数">指数生成函数</h4><p>定义：让 <span class="math inline">\(a_0,a_1,a_2,...\)</span>是一个数列。然后数列 <span class="math inline">\(a\)</span>的指数生成函数（<span class="math inline">\(EGF\)</span>）定义为 <spanclass="math inline">\(A(x)=\sum\limits_{i=0}^{\infty}\frac{a_i}{i!}x^i\)</span></p><p>换句话说，指数生成函数仅仅实在普通生成函数的基础之上，将系数除以<span class="math inline">\(i!\)</span> 。</p><p><strong><span class="math inline">\(Bell\)</span>数的指数生成函数</strong></p><p><span class="math inline">\(Bell\)</span> 数指的是将集合 <spanclass="math inline">\({1,2,3,...,n}\)</span>拆成不相交集合的方案数。例如集合 <spanclass="math inline">\(\{1,2,3\}\)</span> 可以拆成 <spanclass="math inline">\(123;12,3;13,2;1,23;1,2,3\)</span>总共五种方案。</p><p>让我们令 <span class="math inline">\(b_n\)</span> 是第 <spanclass="math inline">\(n\)</span> 个 <spanclass="math inline">\(Bell\)</span> 数，那么根据上述的例子 <spanclass="math inline">\(b_3=5\)</span>，现在我们需要计算其指数生成函数。</p><p>当我们面对的数据量是 <span class="math inline">\(n\leq5000\)</span>时，我们可以 <span class="math inline">\(DP\)</span>的方式来统计方案数。</p><p>假设我们元素 <span class="math inline">\(1\)</span>所在的集合的元素个数为 <spanclass="math inline">\(i\)</span>，那么划分剩下的 <spanclass="math inline">\(n-i\)</span> 个元素的方案数为 <spanclass="math inline">\(b_{n-i}\)</span>，同时选择 <spanclass="math inline">\(i-1\)</span> 个元素的方案数为 <spanclass="math inline">\(C_{n-1}^{i-1}\)</span>。因此根据乘法原理和加法原理就有： <span class="math display">\[b_n=\sum_{i=1}^nC_{n-1}^{i-1}b_{n-i}=\sum_{i=0}^{n-1}C_{n-1}^ib_{n-i-1}=\sum_{i=0}^{n-1}C_{n-1}^{n-1-i}b_{n-i-1}=\sum_{i=0}^{n-1}C_{n-1}^ib_i\]</span> 那么只要预处理组合数，就会得到一个 <spanclass="math inline">\(O(n^2)\)</span> 的 <spanclass="math inline">\(DP\)</span>。在当前的数据量时，是可以通过的，但是如果将数据范围提高到<span class="math inline">\(n\leq3\times10^5\)</span>的时候，就只能使用指数生成函数了。 <span class="math display">\[\begin{align*}&amp;b_n=\sum_{i=0}^{n-1}C_{n-1}^ib_i=\sum_{i=0}^{n-1}\frac{(n-1)!}{i!(n-1-i)!}b_i\\\Rightarrow&amp;\frac{b_n}{(n-1)!}=\sum_{i=0}^{n-1}\frac{b_i}{i!}\cdot\frac{1}{(n-1-i)!}\\\Rightarrow&amp;n\frac{b_n}{n!}=\sum_{i=0}^{n-1}\frac{b_i}{i!}\cdot\frac{1}{(n-1-i)!}\\\Rightarrow&amp;\sum_{n=1}^{\infty}n\frac{b_n}{n!}x^n=\sum_{n=1}^{\infty}x\sum_{i=0}^{n-1}\frac{b_ix^i}{i!}\cdot\frac{x^{n-1-i}}{(n-1-i)!}\end{align*}\]</span>现在我们看到了，为什么指数生成函数对于上面的问题很方便，如果我们的卷积包含二项式系数（通常我们在处理组合问题的时候会遇到），使用<span class="math inline">\(EGF\)</span>将会自动帮助我们对其卷积形式（详细会在后面的卷积部分提及到）</p><p>回到我们上面推出的式子，根据定义来说，等式的右边就是 <spanclass="math inline">\(B(x)\)</span> 和 <spanclass="math inline">\(e^x\)</span> 的卷积，那么等式右边就变成了 <spanclass="math inline">\(xB(x)e^x\)</span> 。（为什么是 <spanclass="math inline">\(e^x\)</span> ，回想 <spanclass="math inline">\(e^x\)</span> 的麦克劳林展开式，<spanclass="math inline">\(e^x=\sum\limits_{n\geq0}\frac{x^n}{n!}\)</span>）等式的左边就需要做一点工作，因为是我们讨厌的 <spanclass="math inline">\(nb_n\)</span> 而不是 <spanclass="math inline">\(b_n\)</span>。而处理这个问题，我们就需要一个处理幂级数的常见技巧，对 <spanclass="math inline">\(B(x)\)</span> <strong>求导</strong>，然后再乘一个<span class="math inline">\(x\)</span> 。 我们验证一下，令 <spanclass="math inline">\(A(x)=a_0+a_1x+a_2x^2+...=\sum\limits_{n\geq0}a_ix^n\)</span>是幂级数，那么 <spanclass="math inline">\(xA&#39;(x)=a_1x+2a_2x^2+3a_3x^3+...=\sum\limits_{n\geq0}na_nx^n\)</span>。 最终上面的式子就变成了 <spanclass="math inline">\(xB&#39;(x)=xB(x)e^x\)</span>，也就是 <spanclass="math inline">\(\frac{B&#39;(x)}{B(x)}=e^x\)</span>。根据我们高数学习到的知识，这是什么？这是变量可分离性的一阶微分方程。我们将<span class="math inline">\(B(x)\)</span> 看成 <spanclass="math inline">\(y\)</span>，那么就会变成： <spanclass="math display">\[\begin{align*}&amp;\frac{y&#39;}{y}=e^x\\\Rightarrow&amp;\frac{\frac{dy}{dx}}{y}=e^x\\\Rightarrow&amp;\frac{dy}{y}=e^xdx\end{align*}\]</span> 两边同时进行积分就能得到： <span class="math display">\[lnB(x)=e^x+C\]</span> 我们已知 <span class="math inline">\(b_0=1，B(0)=1\)</span>就会得到 <span class="math inline">\(C=-1\)</span> ，那么： <spanclass="math display">\[\begin{align*}&amp;lnB(x)=e^x-1\\\Rightarrow&amp;B(x)=e^{e^x-1}\end{align*}\]</span> 最终我们就得到了我们想要的 <spanclass="math inline">\(EGF\)</span>，尽管在形式上可能有点奇怪。</p><p>无论如何，在学习过多项式的算法之后，我们知道能在 <spanclass="math inline">\(O(nlogn)\)</span> 的时间下计算出多项式 <spanclass="math inline">\(e^{P(x)}\)</span> 的前 <spanclass="math inline">\(n\)</span> 项系数。</p><h4 id="生成函数的代数技巧">生成函数的代数技巧</h4><p>这部分会讲解一些操作生成函数的方法，我们将 <spanclass="math inline">\(a_i\)</span> 和 <spanclass="math inline">\(b_i\)</span> 代表生成函数 <spanclass="math inline">\(A(x)\)</span> 和 <spanclass="math inline">\(B(x)\)</span> 的第 <spanclass="math inline">\(i\)</span> 项系数。</p><p><strong>加法</strong></p><p>对于生成函数，<span class="math inline">\(C(x)=A(x)+B(x)\)</span>生成数列 <span class="math inline">\(c_n=a_n+b_n\)</span></p><p><strong>平移</strong></p><p>对于 <span class="math inline">\(OGF\)</span> ，<spanclass="math inline">\(C(x)=x^kA(x)\)</span> 生成数列 <spanclass="math inline">\(c_n=a_{n-k},(a_i=0,i&lt;0)\)</span>。对于 <spanclass="math inline">\(EGF\)</span>，需要对 <spanclass="math inline">\(A(x)\)</span> 积分 <spanclass="math inline">\(k\)</span> 次来达到同样的效果。</p><p>对于 <span class="math inline">\(OGF\)</span> ，<spanclass="math inline">\(C(x)=\frac{A(x)-(a_0+a_1x^1+a_2x^2+...+a_{k-1}x^{k-1})}{x^k}\)</span>生成数列 <span class="math inline">\(c_n=a_{n+k}\)</span></p><p>对于 <span class="math inline">\(EGF\)</span>，<spanclass="math inline">\(C(x)=A^{(k)}(x)\)</span> 生成数列 <spanclass="math inline">\(c_n=a_{n+k}\)</span></p><p><strong>乘以 <span class="math inline">\(n\)</span></strong></p><p>对于 <span class="math inline">\(OGF\)</span> 和 <spanclass="math inline">\(EGF\)</span>，<spanclass="math inline">\(C(x)=xA&#39;(x)\)</span> 的生成数列 <spanclass="math inline">\(c_n=na_n\)</span></p><p><strong>卷积</strong></p><p>卷积对于生成函数来说是一个相当重要的操作。</p><p>对于 <span class="math inline">\(OGF\)</span> 来说，<spanclass="math inline">\(C(x)=A(x)B(x)\)</span> 生成数列 <spanclass="math inline">\(c_n=\sum\limits_{k=0}^na_kb_{n-k}\)</span> 。</p><p>对于 <span class="math inline">\(EGF\)</span> 来说，<spanclass="math inline">\(C(x)=A(x)B(x)\)</span> 生成数列 <spanclass="math inline">\(c_n=\sum\limits_{k=0}^nC_n^ka_kb_{n-k}\)</span> 。证明：<spanclass="math inline">\(A(x)=\sum\limits_{k=0}^{\infty}\frac{a_k}{k!}x^k\)</span>，<spanclass="math inline">\(B(x)=\sum\limits_{k=0}^{\infty}\frac{b_k}{k!}x^k\)</span>，跟<span class="math inline">\(OGF\)</span> 同样的方式，得到 <spanclass="math inline">\(x^n\)</span> 的系数必然是 <spanclass="math inline">\(\sum\limits_{k=0}^{n}\frac{a_k}{k!}\cdot\frac{b_{n-k}}{(n-k)!}\cdotx^n\)</span> 。同时 <spanclass="math inline">\(C(x)=\sum\limits_{k=0}^{\infty}\frac{c_k}{k!}x^k\)</span>，也就是说<span class="math inline">\(k=n\)</span> 时，对应的就是 <spanclass="math inline">\(c_n\frac{x^n}{n!}\)</span>。那么我们对刚才得到的系数做一下恒等变形，变成 <spanclass="math inline">\(\sum\limits_{k=0}^{n}\frac{n!}{k!(n-k)!}a_kb_{n-k}\frac{x^n}{n!}\)</span>，也就是<spanclass="math inline">\(\sum\limits_{k=0}^{n}C_n^ka_kb_{n-k}\frac{x^n}{n!}\)</span>，最终得到<spanclass="math inline">\(c_n=\sum\limits_{k=0}^nC_n^ka_kb_{n-k}\)</span>。</p><p>这也就是为什么说 <span class="math inline">\(EGF\)</span>能够处理菜二项式系数或是阶乘的递归式。</p><p><strong>生成函数的幂</strong></p><p>生成函数的幂也是卷积的一种形式，称为自卷积：</p><p>对于 <span class="math inline">\(OGF\)</span>，<spanclass="math inline">\(C(x)=A(x)^k\)</span> 生成数列 <spanclass="math inline">\(c_n=\sum\limits_{i1+i2+...+ik=n}a_{i1}a_{i2}...a_{ik}\)</span></p><p>对于 <span class="math inline">\(EGF\)</span>，<spanclass="math inline">\(C(x)=A(x)^k\)</span> 生成数列 <spanclass="math inline">\(c_n=\sum\limits_{i1+i2+...+ik=n}\frac{n!}{i_1!i_2!...i_k!}a_{i1}a_{i2}...a_{ik}\)</span></p><p><strong>前缀和技巧</strong></p><p>前缀和技巧只对 <span class="math inline">\(OGF\)</span>有效，假设我们想构造数列 <spanclass="math inline">\(c_n=a_0+a_1+...+a_n\)</span>，那么我们可以令 <spanclass="math inline">\(C(x)=\frac{1}{1-x}A(x)\)</span>，也就是 <spanclass="math inline">\(\sum\limits_{n\geq0}x^n\)</span> 和 <spanclass="math inline">\(\sum\limits_{n\geq0}a_nx^n\)</span> 做卷积。</p><p><strong>常见数列的生成函数</strong></p><p>单位常系数数列生成函数： <span class="math display">\[\frac{1}{1-x}=1+x+x^2+...=\sum_{n=0}^{\infty}x^n\]</span> 调和数列生成函数： <span class="math display">\[-ln(1-x)=x+\frac{x^2}{2}+\frac{x^3}{3}+...=\sum_{n=1}^{\infty}\frac{x^n}{n}\]</span> 单位常系数数列的 <span class="math inline">\(EGF\)</span>（<span class="math inline">\(e^x\)</span> 的麦克劳林展开）： <spanclass="math display">\[e^x=1+x+\frac{x^2}{2!}+\frac{x^3}{3!}+...=\sum_{n=0}^{\infty}\frac{x^n}{n!}\]</span> 二项式系数的列向数列的生成函数： <span class="math display">\[(1-x)^{-k}=C_{k-1}^0x^0+C_k^1x^1+C_{k+1}^2x^2+...=\sum_{n=0}^{\infty}C_{n+k-1}^nx^n\]</span> 我们的目的就是将复杂的函数转换到我们已知的 <spanclass="math inline">\(OGF\)</span> 或是 <spanclass="math inline">\(EGF\)</span> 的封闭形式上去。</p><p>介绍了这么久，那么生成函数都有哪些应用场景呢，我们在下面开始介绍。</p><h4 id="在计数类问题中使用生成函数">在计数类问题中使用生成函数</h4><p>生成函数在排列组合类问题中是一个强有力的工具，下面我们会利用生成函数来解决经典的计数问题。</p><p><strong>重新回顾 <span class="math inline">\(Catalan\)</span>数</strong></p><p>在上文我们已经求出 <span class="math inline">\(Catalan\)</span>数列的 <span class="math inline">\(OGF\)</span> 是 <spanclass="math inline">\(C(x)=\frac{1-\sqrt{1-4x}}{2x}\)</span>。假设我们想找到关于 <span class="math inline">\(c_n\)</span>的封闭形式，想对 <span class="math inline">\(C(x)\)</span>进行展开，但平方根却显得十分麻烦。</p><p>这时候，就需要使用广义二项式定理来帮助我们解决问题，在此我们定义一下广义二项式的系数。</p><p>定义：令 <span class="math inline">\(r\)</span>是任意的实数（其实也可以为复数）而 <spanclass="math inline">\(n\)</span> 是非负整数，那么 <spanclass="math inline">\(C_r^n=\frac{r(r-1)(r-2)...(r-n+1)}{n!}\)</span></p><p>这和二项式系数的定义差不多，只不过取消了对 <spanclass="math inline">\(r\)</span> 是一个非负整数的要求。</p><p>那么广义二项式定理就是： <span class="math display">\[(1+x)^r=\sum_{n=0}^{\infty}C_r^nx^n\]</span> 证明：</p><p>令 <span class="math inline">\(f(x)=(1+x)^r\)</span>，那么 <spanclass="math inline">\(f^{(n)}(x)=r(r-1)(r-2)...(r-n+1)(1+x)^{r-n}\)</span>。</p><p>首先我们联想一下泰勒公式： <span class="math display">\[f(x)=\frac{f(x_0)}{0!}+\frac{f&#39;(x_0)}{1!}(x-x_0)+\frac{f&#39;&#39;(x_0)}{2!}(x-x_0)^2+...+\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)\]</span> 其中 <span class="math inline">\(R_n(x)\)</span> 是 <spanclass="math inline">\(n\)</span> 阶泰勒余项。</p><p>此时由于 <span class="math inline">\(r\)</span>是任意的实数，因此对于 <spanclass="math inline">\(f(x)=(1+x)^r\)</span>，该函数会处于一种无限可导的情况，那么我们直接将泰勒公式展开到无限项：<span class="math display">\[f(x)=\sum_{n=0}^\infty\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n\]</span> 此时右边部分我们称为泰勒级数，而当 <spanclass="math inline">\(x_0=0\)</span> 时得到的级数称为麦克劳林级数，即：<span class="math display">\[f(x)=\sum_{n=0}^\infty\frac{f^{(n)}(0)}{n!}x^n\]</span> 同时我们知道当 <span class="math inline">\(x=0\)</span>时，<spanclass="math inline">\(f^{(n)}(0)=r(r-1)(r-2)...(r-n+1)\)</span>，最终就得到：<span class="math display">\[f(x)=\sum_{n=0}^\infty\frac{r(r-1)(r-2)...(r-n+1)}{n!}x^n\]</span> 也就是： <span class="math display">\[\sum_{n=0}^{\infty}C_r^nx^n\]</span>证明完广义二项式定理的其中一个公式之后（其余更加详细的介绍见多项式的内容），我们再次回到<span class="math inline">\(Catalan\)</span> 数列上。</p><p>现在 <spanclass="math inline">\(\sqrt{1-4x}=(1-4x)^{\frac{1}{2}}=\sum\limits_{n=0}^\inftyC_{\frac{1}{2}}^n(-4x)^n\)</span> 。展开一下得到： <spanclass="math display">\[\begin{align*}&amp;=\sum_{n=0}^\infty\frac{1}{2}\cdot\frac{-1}{2}\cdot\frac{-3}{2}\cdot...\cdot\frac{-(2n-3)}{2}\cdot\frac{1}{n!}\cdot(-4)^nx^n\\&amp;=1+\sum_{n=0}^\infty\frac{(-1)^{n-1}(1\cdot3\cdot5\cdot...\cdot(2n-3))}{2^n}\cdot\frac{(-4)^n}{n!}\cdotx^n\\&amp;=1+\sum_{n=0}^\infty\frac{(-1)^{n-1}(2n-3)!!}{2^n}\cdot\frac{(-4)^n}{n!}\cdotx^n\\&amp;=1+\sum_{n=0}^\infty\frac{(-1)^{n-1}(2n-2)!}{2^n\cdot2^{n-1}\cdot(n-1)!}\cdot\frac{(-4)^n}{n!}\cdotx^n((2n-1)!!=\frac{(2n)!}{2^nn!})\\&amp;=1+\sum_{n=0}^\infty\frac{-2\cdot(2n-2)!}{(n-1)!n!}x^n\\&amp;=1+\sum_{n=0}^\infty-\frac{2}{n}\cdot C_{2n-2}^{n-1}x^n\end{align*}\]</span> 因此： <span class="math display">\[\begin{align*}C(x) &amp;=\frac{1-\sqrt{1-4x}}{2x}=\frac{1}{2x}\cdot(1-1-\sum_{n=0}^\infty-\frac{2}{n}\cdotC_{2n-2}^{n-1}x^n)\\&amp;=\frac{1}{2x}\cdot\sum_{n=0}^\infty \frac{2}{n}\cdotC_{2n-2}^{n-1}x^n\\&amp;=\sum_{n=0}^\infty \frac{1}{n+1}\cdot C_{2n}^{n}x^n\\\end{align*}\]</span> 那么我们就得到 <span class="math inline">\(Catalan\)</span>数列的第 <span class="math inline">\(n\)</span> 项为 <spanclass="math inline">\(c_n=\frac{1}{n+1}C_{2n}^n\)</span> 。</p><p><strong>解决排列类问题</strong></p><p>对于一个排列来说 <spanclass="math inline">\(p=(p_1,p_2,...,p_n)\)</span> 考虑建边操作 <spanclass="math inline">\(i\rightarrowp_i\)</span>。我们会得到一些不相交的环。</p><p><strong>问题 <span class="math inline">\(1\)</span></strong>：<spanclass="math inline">\(n\)</span> 个元素排列中生成 <spanclass="math inline">\(k\)</span> 个环的方案数是多少？这个问题称为第一类斯特林数。</p><p>让 <span class="math inline">\(c_n=(n-1)!\)</span> 是有 <spanclass="math inline">\(n\)</span> 个元素不同环的数量。（其中 <spanclass="math inline">\(n\)</span> 个元素的排列数是 <spanclass="math inline">\(n!\)</span>，但由于环是一个首尾相接的排列，因此对于一个<span class="math inline">\(n\)</span> 个元素的环，对应着 <spanclass="math inline">\(n\)</span> 的不一样的排列，因此 <spanclass="math inline">\(\frac{n!}{n}=(n-1)!\)</span>）让 <spanclass="math inline">\(C(x)=\sum\limits_{n=0}^\infty\frac{c_n}{n!}x^n\)</span>表示 <span class="math inline">\(c\)</span> 的 <spanclass="math inline">\(EGF\)</span> ，让 <spanclass="math inline">\(f_n\)</span> 和 <spanclass="math inline">\(F(x)\)</span> 表示我们的答案数列和对应的 <spanclass="math inline">\(EGF\)</span>。这里我们先给出一个结论：<spanclass="math inline">\(F(x)=\frac{1}{k!}C(x)^k\)</span>。</p><p>首先我们先想这样一个问题：对 <span class="math inline">\(n\)</span>个元素划分成 <span class="math inline">\(k\)</span>个不同种类的方案数是多少？那么答案其实很明显就是 <spanclass="math inline">\(\frac{n!}{a_1!a_2!...a_k!}\)</span>，其中 <spanclass="math inline">\(a_1+a_2+...+a_k=n\)</span>。 <spanclass="math display">\[\begin{align*}C_n^{a_1}C_{n-a_1}^{a_2}C_{n-a_1-a_2}^{a_3}...C_{n-a_1-...-a_{k-1}}^{a_k}&amp;=\frac{n!}{a_1!(n-a_1)!}\cdot\frac{(n-a_1)!}{a_2!(n-a_1-a_2)!}\cdot...\cdot\frac{(n-a_1-a_2-...-a_{k-1})!}{a_k!(n-a_1-a_2-...-a_{k-1}-a_k)!}\\&amp;=\frac{n!}{a_1!a_2!...a_k!}\end{align*}\]</span> 然后每个种类中能组成不同环的个数为 <spanclass="math inline">\(c_{a_i}\)</span> ，最后再除以 <spanclass="math inline">\(k!\)</span> ，因为环之间的排列顺序是无序的。</p><p>总结答案为： <span class="math display">\[\frac{1}{k!}\sum_{a_1+a_2+...+a_k=n}\frac{n!}{a_1!a_2!...a_k!}c_{a_1}c_{a_2}...c_{a_k}\]</span> 那么发现后面的部分为 <spanclass="math inline">\(C(x)^k\)</span>，因此 <spanclass="math inline">\(F(x)=\frac{1}{k!}C(x)^k\)</span>。最后询问 <spanclass="math inline">\((n,k)\)</span> 的答案是，就能使用生成函数在 <spanclass="math inline">\(O(nlogn)\)</span> 的时间内计算出来（计算多项式<span class="math inline">\(P(x)^k=exp(klnP(x))\)</span>的时间复杂度为<span class="math inline">\(O(nlogn)\)</span>）</p><p><strong>问题 <span class="math inline">\(2\)</span></strong>：计算<span class="math inline">\(n\)</span>个元素的置换的个数，且所有环的长度都在一组固定的正整数集合 <spanclass="math inline">\(S\)</span> 中。</p><p>与上一个问题相同的技巧，但还要加一个条件，就是如果长度 <spanclass="math inline">\(i\)</span> 不在 <spanclass="math inline">\(S\)</span> 中则令 <spanclass="math inline">\(c_i=0\)</span>即可。</p><p>这一次我们需要计算 <spanclass="math inline">\([x^n]\sum\limits_{k\geq0}\frac{1}{k!}C(x)^k=[x^n]exp(C(x))\)</span>。因为需要遍历所有的<span class="math inline">\(k\)</span> 并把对应的方案数都加起来。</p><p><strong>问题 <span class="math inline">\(3\)</span></strong> ：计算<span class="math inline">\(n\)</span> 个元素置换中环的期望个数。</p><p>为了计算环的期望个数，我们将所有 <spanclass="math inline">\(n\)</span> 的排列中的所有环数加起来。让 <spanclass="math inline">\(g_n\)</span> 是所有 <spanclass="math inline">\(n\)</span> 的排列中的所有环数而 <spanclass="math inline">\(G(x)\)</span> 是 <spanclass="math inline">\(g\)</span> 的 <spanclass="math inline">\(EGF\)</span> 。我们继续使用辅助 <spanclass="math inline">\(C\)</span>生成函数，我们要计算的是：（注意到这里和上面不同的是多乘了一个 <spanclass="math inline">\(k\)</span>） <span class="math display">\[[x^n]G(x)=[x^n]\sum_{k\geq1}\frac{k}{k!}C(x)^k=[x^n]C(x)\sum_{k\geq1}\frac{1}{(k-1)!}C(x)^{k-1}=[x^n]C(x)exp(C(x))\]</span> 同时，<spanclass="math inline">\(C(x)=\sum\limits_{k\geq1}\frac{(k-1)!}{k!}x^k=\sum\limits_{k\geq1}\frac{x^k}{k}=-ln(1-x)\)</span>，因此<spanclass="math inline">\(C(x)exp(C(x))=-\frac{ln(1-x)}{1-x}\)</span>。那么对于 <span class="math inline">\(n\geq1\)</span> 有 <spanclass="math inline">\([x^n](-ln(1-x))=\frac{1}{n}\)</span>，根据 <spanclass="math inline">\(OGF\)</span> 的前缀和技巧，乘以 <spanclass="math inline">\(\frac{1}{1-x}\)</span>相当于对系数做前缀和，因此： <spanclass="math inline">\([x^n]\frac{ln(1-x)}{1-x}=1+\frac{1}{2}+...+\frac{1}{n}\)</span>，也就是说：<spanclass="math inline">\([x^n]G(x)=1+\frac{1}{2}+...+\frac{1}{n}\)</span>，那么最终的答案即为<spanclass="math inline">\(\sum\limits_{n=1}\frac{1}{n}\)</span>，也就是调和级数。</p><p>我们再一次见到了指数技巧对于处理小物品的方案数是可行的。</p><p><strong>问题 <span class="math inline">\(4\)</span></strong>：将集合<span class="math inline">\({1,2,...,n}\)</span> 划分成 <spanclass="math inline">\(k\)</span> 个不相交子集的方案数是多少？这个问题称为第二类斯特林数。</p><p>我们记答案为 <span class="math inline">\(f(n,k)\)</span>。解决此题的技巧就是利用多项式（也称单位枚举器）<spanclass="math inline">\(D(x)=\sum\limits_{n=1}^\infty\frac{x^n}{n!}\)</span>。那么 <span class="math inline">\(D(x)^k\)</span> 是什么？我们有 <spanclass="math inline">\([x^n]D(x)^k=\sum\limits_{a_1+...+a_k=n,a_i\geq1}\frac{1}{a_1!a_2!...a_k!}\)</span>，因此这个和的意义同之前的解释一样，我们假设我们的子集分别标记<span class="math inline">\(1\)</span> 到 <spanclass="math inline">\(k\)</span>，然后 <spanclass="math inline">\(a_i\)</span> 指的是第 <spanclass="math inline">\(i\)</span> 个集合的大小并且有 <spanclass="math inline">\(\frac{n!}{a_1!a_2!...a_k!}\)</span> 中方案去划分<span class="math inline">\(k\)</span> 个子集，最后我们还要除以 <spanclass="math inline">\(k!\)</span>，因为子集间的顺序是无关的。因此我们最终得到<span class="math inline">\(k!f(n,k)=n![x^n]D(x)^k\)</span>。</p><p>做一下恒等变形，我们就能得到 <spanclass="math inline">\(\frac{f(n,k)}{n!}=\frac{[x^n]D(x)^k}{k!}\)</span>，也就是说<spanclass="math inline">\(\sum\limits_{n=0}^\infty\frac{f(n,k)}{n!}x^n=\frac{D(x)^k}{k!}\)</span>。但这只是关于 <span class="math inline">\(n\)</span> 的 <spanclass="math inline">\(EGF\)</span>，我们还需要在最外层再套一层关于 <spanclass="math inline">\(k\)</span> 的 <spanclass="math inline">\(EGF\)</span> 得到： <span class="math display">\[\sum_{k=0}^\infty\sum_{n=0}^\infty\frac{f(n,k)}{n!}x^ny^k=\sum_{k=0}^\infty\frac{[D(x)y]^k}{k!}=exp(D(x)y)\]</span> 注：我们称多项式 <spanclass="math inline">\(H(x,y)=\sum\limits_{k=0}^\infty\sum\limits_{n=0}^\infty\frac{f(n,k)}{n!}x^ny^k\)</span>为手动枚举器。</p><p>因此，我们有一个简单记法的等式 <spanclass="math inline">\(H(x,y)=exp(D(x)y)\)</span>。由于 <spanclass="math inline">\(D(x)=\sum\limits_{n=1}^\infty\frac{x^n}{n!}=e^x-1\)</span>，因此<spanclass="math inline">\(H(x,y)=e^{(e^x-1)y}\)</span>，观察可以发现，当<span class="math inline">\(y=1\)</span> 时，<spanclass="math inline">\(H(x,1)\)</span> 就是 <spanclass="math inline">\(Bell\)</span> 数的生成函数（<strong>为什么？</strong>）</p><p>为了计算答案，我们只需要找到 <spanclass="math inline">\(n![x^ny^k]H(x,y)=n![x^n]\frac{(e^x-1)^k}{k!}\)</span>，对于这个式子可以使用多项式运算来有效计算它。</p><p><strong>图计数问题</strong></p><p><strong>问题 <spanclass="math inline">\(5\)</span></strong>：总共有多少种 <spanclass="math inline">\(n\)</span> 个带标号节点的无向图，其中每个节点度为<span class="math inline">\(2\)</span> ？</p><p>每一个这样的图必须是由不相交的环组成（可以考虑从反证法进行入手证明。）一般情况下，我们考虑对于一个连通分量的生成函数作为切入点。让<span class="math inline">\(d_n\)</span> 为一个带标记节点的数量为 <spanclass="math inline">\(n\)</span> 的一个无向环的方案数而 <spanclass="math inline">\(D(x)\)</span> 为 <spanclass="math inline">\(d\)</span> 的 <spanclass="math inline">\(EGF\)</span>。那么： <span class="math display">\[D(x)=\sum_{n\geq3}\frac{(n-1)!}{2}\cdot\frac{x^n}{n!}=\frac{1}{2}\sum_{n\geq3}\frac{x^n}{n}=\frac{1}{2}(-ln(1-x)-x-\frac{x^2}{2})\]</span> （由上文我们得到 <span class="math inline">\(n\)</span>个元素不同环的数量为 <spanclass="math inline">\((n-1)!\)</span>，但是此时的环是有向环，因此转化成无向环的数量还需要再除以<span class="math inline">\(2\)</span>）</p><p>同时我们让 <span class="math inline">\(G(x)\)</span> 是我们答案的<span class="math inline">\(EGF\)</span> 。使用之前的分析过程，我们发现<span class="math inline">\(G(x)=exp(D(x))\)</span> 。（对 <spanclass="math inline">\(D(x)^k\)</span> 求和即可得到）因此最终的答案为：<span class="math display">\[G(x)=exp\bigg(\ln\bigg(\sqrt{\frac{1}{1-x}}\bigg)-\frac{x}{2}-\frac{x^2}{4}\bigg)=\frac{e^{-\frac{x}{2}-\frac{x^2}{4}}}{\sqrt{1-x}}\]</span> 那么只要计算出 <span class="math inline">\(x^n\)</span>的系数就能获得答案。</p><p>问题 <span class="math inline">\(6\)</span>：有 <spanclass="math inline">\(n\)</span>个带标号节点的二分图（可能不连通）的个数是多少？</p><p>第一眼我们非常想用上面的技巧来解决这个问题。我们可以建立一般的二分图和连通的二分图的数量之间的关系。但是我们能简单的计算出连通二分图的数量吗？不幸的是，很显然无法简单的直接计算出来。</p><p>换一种思路，我们去对无向图进行红蓝染色，之后计算染色后二分图（不必连通）的数量。假设将<span class="math inline">\(k\)</span> 个节点染成红色，将 <spanclass="math inline">\(n-k\)</span> 个节点染成蓝色，那么我们就有 <spanclass="math inline">\(C_n^k\)</span> 种染色方案和 <spanclass="math inline">\(2^{k(n-k)}\)</span> 种连边方案（因为有 <spanclass="math inline">\(k(n-k)\)</span> 个可连的边）。因此，<spanclass="math inline">\(n\)</span> 个带标号节点的染色二分图数量为 <spanclass="math inline">\(\sum\limits_{k\geq0}C_n^k2^{k(n-k)}\)</span>。此时称这个数列为<span class="math inline">\(a_n\)</span>，并且它的 <spanclass="math inline">\(EGF\)</span> 记为 <spanclass="math inline">\(A(x)\)</span>。</p><p>下一步就是建立带标号节点的染色二分图的数量和连通的带标号节点的染色二分图的数量。令<span class="math inline">\(b_n\)</span> 为 <spanclass="math inline">\(n\)</span>个连通的带标号节点的染色二分图数量并且它的 <spanclass="math inline">\(EGF\)</span> 记为 <spanclass="math inline">\(B(x)\)</span> 。那么根据上面同样的方式我们就能得到<span class="math inline">\(A(x)=exp(B(x))\)</span>，也就是 <spanclass="math inline">\(B(x)=ln(A(x))\)</span>。</p><p>回到原问题，我们下一步就是计算 <span class="math inline">\(n\)</span>个带标号节点的连通的二分图的数量，记为 <spanclass="math inline">\(c_n\)</span> 且 <spanclass="math inline">\(EGF\)</span> 记为 <spanclass="math inline">\(C(x)\)</span>。然而这令人意外的简单，因为 <spanclass="math inline">\(n\)</span>个连通的带标号节点的染色二分图将这个图唯一的分成了两个部分（仅仅交换红蓝两个颜色）。因此<span class="math inline">\(C(x)=\frac{B(x)}{2}\)</span> 。</p><p>最后我们令 <span class="math inline">\(d_n\)</span> 为我们答案的<span class="math inline">\(EGF\)</span>，那么 <spanclass="math inline">\(D(x)=exp(C(x))\)</span> 。也就是说： <spanclass="math display">\[D(x)=exp(C(x))=exp\bigg(\frac{B(x)}{2}\bigg)=exp\bigg(\frac{ln(A(x))}{2}\bigg)=\sqrt{A(x)}\]</span> 问题 <span class="math inline">\(7\)</span> ：考虑一个 <spanclass="math inline">\(n\times n\)</span>的棋盘，棋盘中一些格子是黑色的另一些是白色的。假设我们突然想知道一个数列<span class="math inline">\(r_k\)</span>，<spanclass="math inline">\(r_k\)</span> 代表只在白色格子上放置 <spanclass="math inline">\(k\)</span>个互不攻击车（没有两个车在同一行或同一列，没有车在黑色方格上）的方案数。令<span class="math inline">\(e_k\)</span> 为放置 <spanclass="math inline">\(n\)</span> 个互不攻击的车，而这 <spanclass="math inline">\(n\)</span> 个车有恰好 <spanclass="math inline">\(k\)</span> 个在白色格子上的方案数。我们可以用<span class="math inline">\(r_k\)</span> 计算 <spanclass="math inline">\(e_k\)</span>吗？</p><p>这个技巧就是“至少”这个条件的计数要比“恰好”这个条件的计数更简单。对于一个由白色棋子组成的固定的子集<span class="math inline">\(S\)</span>，令 <spanclass="math inline">\(N(S)\)</span> 指的是放置 <spanclass="math inline">\(n\)</span> 个互不攻击的车保证至少 <spanclass="math inline">\(S\)</span> 集合的格子上都有车。令 <spanclass="math inline">\(n_k=\sum\limits_{|S|=k}N(S)\)</span> 。</p><p>我们建立 <span class="math inline">\(n_k\)</span> 和 <spanclass="math inline">\(e_k\)</span> 之间的关系。考虑一个大小为 <spanclass="math inline">\(t\)</span> 的子集 <spanclass="math inline">\(T\)</span> 和一种放置 <spanclass="math inline">\(n\)</span>个互不攻击的车满足他们占据白色的格子正好是集合 <spanclass="math inline">\(T\)</span>。<span class="math inline">\(T\)</span>中每一个大小为 <span class="math inline">\(k\)</span> 的子集都对 <spanclass="math inline">\(n_k\)</span> 有贡献。因此，我们得到了一个循环式<spanclass="math inline">\(n_k=\sum\limits_{t\geq0}C_t^ke_t\)</span>。</p><p>让我们令 <span class="math inline">\(N(x)\)</span> 和 <spanclass="math inline">\(E(x)\)</span> 分别是 <spanclass="math inline">\(n_k\)</span> 和 <spanclass="math inline">\(e_k\)</span> 的 <spanclass="math inline">\(OGF\)</span>。之间我们能导出一个简单的关系。这样的话，我们就有：<span class="math display">\[N(x)=\sum_{k\geq0}x^k\sum_{t\geq0}C_t^ke_t=\sum_{t\geq0}e_t\sum_{k\geq0}C_t^kx^k=\sum_{t\geq0}e_t(x+1)^t=E(x+1)\]</span> 因此，我们有一个简单的式子 <spanclass="math inline">\(E(x)=N(x-1)\)</span>。</p><p><span class="math inline">\(n_k\)</span> 更加好计算，在我们的问题中<span class="math inline">\(n_k=r_k(n-k)!\)</span>。因为我们可以首先选择 <span class="math inline">\(k\)</span>个在白色格子上的互不攻击的车作为集合 <spanclass="math inline">\(S\)</span>，然后放置剩下的 <spanclass="math inline">\(n-k\)</span> 个棋子，方案数为 <spanclass="math inline">\((n-k)!\)</span> 。因此，我们能得到 <spanclass="math inline">\(N(x)=\sum\limits_{k\geq0}r_k(n-1)!x^k\)</span>，进而<spanclass="math inline">\(E(x)=\sum\limits_{k\geq0}r_k(n-k)!(x-1)^k\)</span>。因此我们能读取 <span class="math inline">\(E(x)\)</span>的系数作为答案。</p><h4id="使用生成函数证明一些有趣的定理">使用生成函数证明一些有趣的定理</h4><p>一个分拆是将 <span class="math inline">\(n\)</span> 分拆成 <spanclass="math inline">\(k\)</span>个元素的多重集合并且集合中的元素加起来等于 <spanclass="math inline">\(n\)</span> 。例如，集合 <spanclass="math inline">\(\{3,1,1\}\)</span> 是 <spanclass="math inline">\(5\)</span> 的一个分拆。注意到集合是无序的。</p><p><strong>分拆为奇数元素 = 分拆为互不相同的元素</strong></p><p>你可能已经知道分拆 <span class="math inline">\(n\)</span>为奇数元素的方案数等于分拆 <span class="math inline">\(n\)</span>为互不相同元素的方案数。那么我们证明更一般性的问题。</p><p><strong>问题：</strong>将 <span class="math inline">\(n\)</span>分拆成元素不能被 <span class="math inline">\(k+1\)</span>整除的集合的方案数等于将 <span class="math inline">\(n\)</span>分拆成一个多重集合，满足这个多重集合的最大重数不能超过 <spanclass="math inline">\(k\)</span> 的方案数。（多重集的定义：是集合概念的推广，在多重集中同一个元素可以出现多次重数的定义：一个元素在多重集里出现的次数称为这个元素在多重集里面的重数）</p><p>注意到当 <span class="math inline">\(k=1\)</span>的时候就是我们的原问题。</p><p>固定 <span class="math inline">\(k\)</span> 让 <spanclass="math inline">\(A(x)\)</span> 是左侧计数的 <spanclass="math inline">\(OGF\)</span>，而 <spanclass="math inline">\(B(x)\)</span> 是右侧计数的 <spanclass="math inline">\(OGF\)</span>。观察到对于将 <spanclass="math inline">\(n\)</span>分拆成一个多重集合，满足将这个多重集合的最大重数不能超过 <spanclass="math inline">\(k\)</span>，我们可以从 <spanclass="math inline">\(1\)</span>开始枚举集合内的元素，并且根据元素的重数卷积生成函数： <spanclass="math display">\[\begin{align*}B(x)&amp;=\prod_{r\geq1}(1+x^r+x^{2r}+...+x^{kr})=\prod_{r\geq1}\frac{1-x^{r(k+1)}}{1-x^r}\\&amp;=\prod_{r\geq1}1-x^{r(k+1)}\bigg(\prod_{r\geq1,(k+1)\nmidr}\frac{1}{1-x^r}\prod_{r\geq1,(k+1)\mid r}\frac{1}{1-x^r}\bigg)\\&amp;=\prod_{r\geq1}1-x^{r(k+1)}\bigg(\prod_{r\geq1,(k+1)\nmidr}\frac{1}{1-x^r}\ \prod_{r\geq1}\frac{1}{1-x^{r(k+1)}}\bigg)\\&amp;=\prod_{r\geq1,(k+1)\nmid r}\frac{1}{1-x^r}\\&amp;=\prod_{r\geq1,(k+1)\nmid r}(1 + x^r+x^{2r}+...)=A(x)\end{align*}\]</span> <strong><span class="math inline">\(Binet&#39; s\)</span>公式（解决线性递推）</strong></p><p>令 <span class="math inline">\(f_n\)</span> 指的是第 <spanclass="math inline">\(n\)</span> 个斐波那契数 （<spanclass="math inline">\(f_0=0,f_1=1,f_n=f_{n-1}+f_{n-2}\)</span>）。那么<spanclass="math inline">\(Binet&#39; s\)</span> 公式就是 <spanclass="math inline">\(f_n=\frac{1}{\sqrt{5}}\big[(\frac{1+\sqrt{5}}{2})^n-(\frac{1-\sqrt{5}}{2})^n\big]\)</span>。</p><p>这看起来很随意，但也确实直接来自生成函数。我们知道 <spanclass="math inline">\(F(x)=\frac{x}{1-x-x^2}\)</span> 是 <spanclass="math inline">\(f\)</span> 的 <spanclass="math inline">\(OGF\)</span>，而这次我们所要用到的技巧就是<strong>分式裂项</strong>。我们让<span class="math inline">\(-\gamma_1\)</span> 和 <spanclass="math inline">\(-\gamma_2\)</span> 是方程 <spanclass="math inline">\(1-x-x^2=0\)</span> 的两个根（解出来得 <spanclass="math inline">\(\gamma_1=\frac{1+\sqrt{5}}{2},\gamma_2=\frac{1-\sqrt{5}}{2}\)</span>）。然后我们写出<spanclass="math inline">\(F(x)=\frac{A}{x+\gamma_1}+\frac{B}{x+\gamma_2}\)</span>，其中<span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 是待定系数，通过计算我们可以得到：<span class="math display">\[F(x)=\frac{1}{\gamma_1-\gamma_2}\big(\frac{1}{1-\gamma_1x}-\frac{1}{1-\gamma_2x}\big)=\frac{1}{\sqrt{5}}\bigg(\sum_{j\geq0}\gamma_1^jx^j-\sum_{j\geq0}\gamma_2^jx^j\bigg)=\sum_{j\geq0}\frac{1}{\sqrt{5}}(\gamma_1^j-\gamma_2^j)x^j\]</span> 那么我们就能得到 <spanclass="math inline">\(f_n=\frac{1}{\sqrt{5}}(\gamma_1^n-\gamma_2^n)\)</span>，也就是我们提到的<span class="math inline">\(Binet&#39; s\)</span> 公式。</p><p>注意到这个方法对于一般的线性递推公式也适用。</p><p><strong>随机排列得到一个没有环的长度是平方数的概率</strong></p><p>这个问题看起来非常的随机，但是可以展示生成函数有多么强大。</p><p>首先我们假设我们知道的 <span class="math inline">\(n\)</span>个元素的排列并且环长为 <span class="math inline">\(i\)</span>的环的数量为 <span class="math inline">\(a_i\)</span>，并满足 <spanclass="math inline">\(\sum\limits_{i\geq1}ia_i=n\)</span>。有多少个排列满足此要求？通过简单的计数（回想一下第一类斯特林数的过程），我们可以得到公式：<span class="math display">\[\frac{n!\prod_\limits{i\geq1}((i-1)!)^{a_i}}{\prod_\limits{i\geq1}(i!)^{a_i}\prod\limits_{i\geq1}(a_i!)}=\frac{n!}{\prod_\limits{i\geq1}i^{a_i}\prod\limits_{i\geq1}(a_i!)}\]</span>（博客中也给出了提示：先考虑对环进行标记，然后安排每个环中的元素，然后考虑每一个环内的方案数，最后除以一些重复的因子。）</p><p>定义序列 <span class="math inline">\(a=(a_1,a_2,...,a_n)\)</span>称为一个排列的环形。</p><p>让 <span class="math inline">\(c(a)\)</span> 为环形为 <spanclass="math inline">\(a\)</span> 的排列方案数，令 <spanclass="math inline">\(p(a)\)</span> 为得到环形为 <spanclass="math inline">\(a\)</span> 的概率，那么 <spanclass="math inline">\(c(a)=\frac{n!}{\prod_\limits{i\geq1}i^{a_i}\prod\limits_{i\geq1}(a_i!)},p(a)=\frac{c(a)}{n!}\)</span>。</p><p>现在，我们考虑一种称为无限变量 <spanclass="math inline">\(x_1,x_2,...,x_n\)</span> 参数的生成函数： <spanclass="math display">\[C(x,y)=\sum_{n\geq0}\frac{y^n}{n!}\sum_{a_1+2a_2+...=n,a_i\geq0}c(a)x^{a_1}x^{a_2}...\]</span> 我们已经知道了 <span class="math inline">\(c(a)\)</span>的公式，因此代入 <span class="math inline">\(c(a)\)</span>我们就会得到： <span class="math display">\[C(x,y)=\bigg(\sum_{a_1\geq0}\frac{(yx_1)^{a_1}}{a_1!1^{a_1}}\bigg)\bigg(\sum_{a_2\geq0}\frac{(y^2x_2)^{a_2}}{a_2!2^{a_2}}\bigg)...=exp(yx_1)exp(\frac{y^2x_2}{2})...=exp\bigg(\sum_{i\geq1}\frac{y^ix_i}{i}\bigg)\]</span> 因此，对于一个固定环形 <spanclass="math inline">\(p(a)=[y^nx_1^{a_1}x_2^{a_2}...]exp\big(\sum\limits_{i\geq1}\frac{y^ix_i}{i}\big)\)</span>。</p><p>让我们回到原问题上，称一个环形是一个好环形当且仅当对于所有的完全平方数<span class="math inline">\(j\)</span> 都有 <spanclass="math inline">\(a_j=0\)</span>。我们想计算 <spanclass="math inline">\(\lim_\limits{n\to+\infty}\sum_\limits{a\good}[y^nx_1^{a_1}x_2^{a_2}...]exp\big(\sum\limits_{i\geq1}\frac{y^ix_i}{i}\big)\)</span>。我们可以对于所有的非完全平方数 <span class="math inline">\(j\)</span>都代入 <span class="math inline">\(x_j=1\)</span> 来说明我们不关心 <spanclass="math inline">\(x_j\)</span>的指数（同时注意此时对于所有完全平方数 <spanclass="math inline">\(j\)</span>，<spanclass="math inline">\(a_j=0\)</span>），因此问题就变成了： <spanclass="math display">\[\begin{align*}\lim_\limits{n\to+\infty}[y^n]exp\bigg(\sum\limits_{i=z^2}\frac{y^ix_i}{i}+\sum\limits_{i\neqz^2}\frac{y^i}{i}\bigg)&amp;=\lim_\limits{n\to+\infty}[y^n]exp\bigg(\sum\limits_{i=z^2}\frac{y^i(x_i-1)}{i}+\sum\limits_{i\geq1}\frac{y^i}{i}\bigg)\\&amp;=\lim_\limits{n\to+\infty}[y^n]exp\bigg(\sum\limits_{i=z^2}\frac{y^i(x_i-1)}{i}-ln(1-y)\bigg)\\&amp;=\lim_\limits{n\to+\infty}[y^n]\frac{1}{1-y}exp\bigg(\sum\limits_{i=z^2}\frac{y^i(x_i-1)}{i}\bigg)\end{align*}\]</span> 令 <span class="math inline">\(A(x)\)</span> 是 <spanclass="math inline">\(a_n=[y^n]exp\big(\sum\limits_{i=z^2}\frac{y^i(x_i-1)}{i}\big)\)</span>的 <spanclass="math inline">\(OGF\)</span>，然后根据前缀和技巧，我们的极限就等于<spanclass="math inline">\(\lim\limits_{n\to+\infty}\sum\limits_{i\geq0}a_i\)</span>。（假设和收敛，实际上确实是收敛的）</p><p>直觉上，我们直接代入 <span class="math inline">\(y=1\)</span> 到<spanclass="math inline">\(exp\bigg(\sum\limits_{i=z^2}\frac{y^i(x_i-1)}{i}\bigg)\)</span>，我们想计算常数项（没有 <span class="math inline">\(x_i\)</span> 的项）并且此时 <spanclass="math inline">\(x_i\)</span> 中的 <spanclass="math inline">\(i\)</span> 一定是完全平方数，所以我们代入 <spanclass="math inline">\(x_i=0\)</span>，得到： <spanclass="math display">\[\lim_\limits{n\to+\infty}[y^n]\frac{1}{1-y}exp\bigg(\sum\limits_{i=z^2}\frac{y^i(x_i-1)}{i}\bigg)=exp\bigg(\sum\limits_{i=z^2}-\frac{1}{i}\bigg)=e^{-\frac{\pi^2}{6}}\]</span> 这就是我们的答案（回想一下 <spanclass="math inline">\(\sum\limits_{i\geq1}\frac{1}{i^2}=\frac{\pi^2}{6}\)</span>）</p><h4id="一些在证明或发明组合等式的丝滑技巧">一些在证明或发明组合等式的丝滑技巧</h4><p>这个思想就是宁可直接处理和式，我们不如通过生成函数处理级数更加简单。</p><p>计算和式 <spanclass="math inline">\(\sum\limits_{k\geq0}C_k^{n-k}\)</span>，其中 <spanclass="math inline">\(n\)</span> 是固定的。</p><p>假设我们的问题是计算 <spanclass="math inline">\(f(n)\)</span>。考虑计算 <spanclass="math inline">\(F(x)\)</span> 的思路更简单，这里 <spanclass="math inline">\(F(x)=\sum\limits_{n\geq0}f(n)x^n\)</span>。</p><p>我们有： <span class="math display">\[F(x)=\sum_{n\geq0}f(n)x^n=\sum_{n\geq0}\sum_{k\geq0}C_k^{n-k}x^n=\sum_{k\geq0}\sum_{n\geq0}C_k^{n-k}x^n\]</span>这个关键的思路就是是的内层和式计算的更见简单。我们已经知道如何计算 <spanclass="math inline">\(\sum\limits_{n\geq0}C_k^{n-k}x^{n-k}\)</span>。因为它和 <spanclass="math inline">\(\sum\limits_{r\geq0}C_k^{r}x^{r}\)</span>一样，唯一的区别是 <span class="math inline">\(r=n-k\)</span> 。</p><p>因此，我们进行如下计算： <span class="math display">\[\sum_{k\geq0}\sum_{n\geq0}C_k^{n-k}x^n=\sum_{k\geq0}x^k\sum\limits_{n\geq0}C_k^{n-k}x^{n-k}=\sum_{k\geq0}(x(1+x))^k=\frac{1}{1-x-x^2}\]</span> 这个式子十分的眼熟，就是 <spanclass="math inline">\(\frac{F(x)}{x}\)</span>，而 <spanclass="math inline">\(F(x)\)</span> 实际上就是斐波那契数列的 <spanclass="math inline">\(OGF\)</span>。因此 <spanclass="math inline">\(\frac{1}{1-x-x^2}=\sum\limits_{n\geq0}f_{n+1}x^n\)</span>，那么我们的<span class="math inline">\(f(n)=f_{n+1}\)</span> ，就是第 <spanclass="math inline">\(n+1\)</span> 个斐波那契数。</p><p>还有许多类似的丝滑的技巧，但是我在这里不会去详细解释。一般的，这些技巧在竞赛中也许有用，特别是当你遇到了二重或三重带组合数的和式，然后你还特别想在<span class="math inline">\(O(n)\)</span>的时间内算出来。我们将会在下一部分使用这些技巧。</p><p>练习：证明范德蒙德卷积，即：<spanclass="math inline">\(\sum\limits_{r=0}^kC_m^rC_n^{k-r}=C_{n+m}^{k}\)</span></p>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类欧几里得算法</title>
    <link href="/2024/01/15/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    <url>/2024/01/15/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="类欧几里得算法">类欧几里得算法</h1><p>参考资料：</p><ol type="1"><li><ahref="https://www.luogu.com.cn/blog/LinearExpectation/Akin-Euclidean-algorithm-Basis">数论笔记：类欧几里得算法的盛宴- Aw顿顿の小窝 · Linear Expectation 线性期望 - 洛谷博客(luogu.com.cn)</a></li><li><ahref="https://www.luogu.com.cn/blog/LinearExpectation/Akin-Euclidean-algorithm-Advanced">数论笔记：且听鹤鸣于九皋，类欧几里得算法进阶- Aw顿顿の小窝 · Linear Expectation 线性期望 - 洛谷博客(luogu.com.cn)</a></li></ol><p>给定 <span class="math inline">\(a, b, c, n\)</span> ，通过 <spanclass="math inline">\(O(logn)\)</span> 的复杂度求解下面的公式： <spanclass="math display">\[\sum_{x=0}^n \ \bigg\lfloor \frac{ax+b}{c} \bigg\rfloor\]</span>从几何的角度来理解就是<strong>“求直线在给定区间下包含整点的个数”</strong></p><p>在欧几里得算法中，计算 <span class="math inline">\(gcd\)</span>时选择用函数的形式进行处理，在这里也采取同样的方式，将上述公式写成普通函数的形式：<span class="math display">\[f(a,b,c,n)=\sum_{x=0}^n \ \bigg\lfloor \frac{ax+b}{c} \bigg\rfloor\]</span> 那么接下来的任务就是化简。</p><h5 id="取模化简">取模化简</h5><p>取模化简的目的在于将 <span class="math inline">\(a \geq c\)</span> 或<span class="math inline">\(b\geq c\)</span> 的情况转化为 <spanclass="math inline">\(a&lt;c,\ b&lt;c\)</span> 的情况。</p><p>首先，我们对 <span class="math inline">\(a\)</span> 和 <spanclass="math inline">\(b\)</span> 均进行下面的处理方式： <spanclass="math display">\[a=(a\ mod\ c) + (a-a\ mod\ c)\\b=(b\ mod\ c) + (b-b\ mod\ c)\]</span> 因此函数就被转化为： <span class="math display">\[f(a,b,c,n)=\sum_{x=0}^n \ \bigg\lfloor \frac{(a\ mod\ c)x + (a-a\ mod\c)x+(b\ mod\ c) + (b-b\ mod\ c)}{c} \bigg\rfloor\]</span> 观察可以发现，<span class="math inline">\((a-a\ mod\c)\)</span> 和 <span class="math inline">\((b-b\ mod\ c)\)</span>都是能整除 <span class="math inline">\(c\)</span>的部分，将这两部分提取出来可以得到： <span class="math display">\[f(a,b,c,n)=\sum_{x=0}^n \ \bigg\lfloor \frac{(a\ mod\ c)x+(b\ mod\c)}{c} \bigg\rfloor+\frac{(a-a\ mod\ c)x}{c}+\frac{(b-b\ mod\ c)}{c}\]</span> 利用计算机整除为下取整的性质，进一步将函数化简成： <spanclass="math display">\[f(a,b,c,n)=\sum_{x=0}^n \ \bigg\lfloor \frac{(a\ mod\ c)x+(b\ mod\c)}{c} \bigg\rfloor+\bigg\lfloor\frac{a}{c} \bigg\rfloorx+\bigg\lfloor\frac{b}{c} \bigg\rfloor\]</span>因此，后两项就能从求和公式中提取出来，前者利用等差数列求和公式进行提取，最终得到：<span class="math display">\[f(a,b,c,n)=\frac{n(n+1)}{2}\times\bigg\lfloor\frac{a}{c} \bigg\rfloor +(n+1)\times\bigg\lfloor\frac{b}{c} \bigg\rfloor + \sum_{x=0}^n \\bigg\lfloor \frac{(a\ mod\ c)x+(b\ mod\ c)}{c} \bigg\rfloor\]</span>这是我们可以发现，求和部分和函数定义是完全一样的，因此将其写成函数形式：<span class="math display">\[f(a,b,c,n)=\frac{n(n+1)}{2}\times\bigg\lfloor\frac{a}{c} \bigg\rfloor +(n+1)\times\bigg\lfloor\frac{b}{c} \bigg\rfloor + f(a\ mod\ c,b\ mod\c,c,n)\]</span> 这样子，就能将函数的情况转化为 <spanclass="math inline">\(a&lt;c,\ b&lt;c\)</span> 的情况。</p><h5 id="贡献化简">贡献化简</h5><p>首先还是这个式子： <span class="math display">\[\sum_{x=0}^n \ \bigg\lfloor \frac{ax+b}{c} \bigg\rfloor\]</span> 那么对于这个式子来讲，<span class="math inline">\(x\leqn\)</span> 是条件，而 <span class="math inline">\(\lfloor \frac{ax+b}{c}\rfloor\)</span> 是这个循环的贡献。</p><p>因此，对于后者 <span class="math inline">\(\lfloor \frac{ax+b}{c}\rfloor\)</span>，考虑也采用这样记录贡献的方式，将式子本身作为条件，而循环的贡献为 <spanclass="math inline">\(1\)</span>，即原式子化为： <spanclass="math display">\[\bigg\lfloor \frac{ax+b}{c} \bigg\rfloor=\sum_{j=0}^{\lfloor\frac{ax+b}{c} \rfloor-1}1\]</span> 减 <span class="math inline">\(1\)</span> 的原因在于 <spanclass="math inline">\(j\)</span> 是从 <spanclass="math inline">\(0\)</span> 开始进行循环的。</p><p>最终原式子就变成了： <span class="math display">\[\sum_{x=0}^n \sum_{j=0}^{\lfloor \frac{ax+b}{c} \rfloor-1}1\]</span> 通过观察得到，<span class="math inline">\(j\)</span>的上界只受到 <span class="math inline">\(x\)</span> 的限制，同样的 <spanclass="math inline">\(x\)</span> 的上界只受到 <spanclass="math inline">\(n\)</span> 的限制，因此在这里可以选择调换 <spanclass="math inline">\(j\)</span> 和 <spanclass="math inline">\(x\)</span> 的位置使得两者都被 <spanclass="math inline">\(n\)</span> 限制且不影响结果，最后原式子变成：<span class="math display">\[\sum_{j=0}^{\lfloor \frac{an+b}{c} \rfloor-1}\sum_{x=0}^n\\bigg[j&lt;\bigg\lfloor \frac{ax+b}{c} \bigg\rfloor\bigg]\]</span> 这时候，观察逻辑表达式的部分，并尝试对其进行化简： <spanclass="math display">\[j&lt;\bigg\lfloor \frac{ax+b}{c} \bigg\rfloor\]</span> 由于两者都是整数，因此两者差距至少为 <spanclass="math inline">\(1\)</span>，因此转化为如下式子： <spanclass="math display">\[j+1\leq\bigg\lfloor \frac{ax+b}{c} \bigg\rfloor\]</span> 同时下取整的结果一定满足小于等于原数，即： <spanclass="math display">\[j+1\leq\bigg\lfloor \frac{ax+b}{c} \bigg\rfloor\leq \frac{ax+b}{c}\]</span> 那么原不等式变成了： <span class="math display">\[j+1\leq \frac{ax+b}{c}\]</span> 在进行恒等变形得到： <span class="math display">\[cj+c-b\leq ax\]</span> 同样的，在不等式左边减去一个 <spanclass="math inline">\(1\)</span> ，小于等于号变为小于号，不等式变为：<span class="math display">\[cj+c-b-1&lt;ax\]</span> 再次进行恒等变形： <span class="math display">\[\frac{cj+c-b-1}{a}&lt;x\]</span> 取下取整： <span class="math display">\[\bigg\lfloor \frac{cj+c-b-1}{a} \bigg\rfloor&lt;x\]</span> 也就是说，我们将原先的逻辑表达式替换成了有关于 <spanclass="math inline">\(x\)</span> 的逻辑表达式，那么原式变成了： <spanclass="math display">\[\sum_{j=0}^{\lfloor \frac{an+b}{c} \rfloor-1}\sum_{x=0}^n\ \bigg[x &gt;\bigg\lfloor \frac{cj+c-b-1}{a} \bigg\rfloor\bigg]\]</span> 令 <span class="math inline">\(m=\big\lfloor\frac{an+b}{c}\big\rfloor\)</span>，同时也可以发现关于 <spanclass="math inline">\(x\)</span> 的求和部分可以进行化简： <spanclass="math display">\[\sum_{j=0}^{m-1}\ \bigg(n- \bigg\lfloor \frac{cj+c-b-1}{a}\bigg\rfloor\bigg)\]</span> 将 <span class="math inline">\(n\)</span>提取出来，最终写成函数形式即为： <span class="math display">\[f(a,b,c,n)=nm-\sum_{j=0}^{m-1}\ \bigg\lfloor \frac{cj+c-b-1}{a}\bigg\rfloor\]</span> 此时观察最初的函数定义： <span class="math display">\[f(a,b,c,n)=\sum_{x=0}^n \ \bigg\lfloor \frac{ax+b}{c} \bigg\rfloor\]</span> 也就是说，我们将 <span class="math inline">\(m-1\)</span> 看成<span class="math inline">\(n\)</span> ，<spanclass="math inline">\(j\)</span> 看成 <spanclass="math inline">\(x\)</span> ，<spanclass="math inline">\(c\)</span> 看成 <spanclass="math inline">\(a\)</span>，<spanclass="math inline">\(c-b-1\)</span> 看成 <spanclass="math inline">\(b\)</span> ，<spanclass="math inline">\(a\)</span> 看成 <spanclass="math inline">\(c\)</span>，那么后面的求和部分就变成了函数形式，可以进行递归调用了： <spanclass="math display">\[f(a,b,c,n)=nm-f(c,c-b-1,a,m-1)\]</span> 因此如果函数存在 <span class="math inline">\(a\geq c\)</span>或 <span class="math inline">\(b\geq c\)</span>的情况，先使用取模化简的方式将 <span class="math inline">\(a\)</span> 和<span class="math inline">\(b\)</span> 都控制在 <spanclass="math inline">\(a&lt;c\)</span> 且 <spanclass="math inline">\(b&lt;c\)</span>的情况，然后再用贡献化简的方式进行递归，并重复这一过程。</p><p>这样反复缩小数量级的过程和我们学过求 <spanclass="math inline">\(gcd\)</span>的辗转相除法（即欧几里得算法）十分相似，因此<strong>类欧几里得算法</strong> 由此得来。</p><p>时间复杂度： <span class="math inline">\(O(logn)\)</span></p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>((b / c) * (n + <span class="hljs-number">1</span>));<br>    <span class="hljs-keyword">if</span>(a &gt;= c || b &gt;= c) <span class="hljs-keyword">return</span> <span class="hljs-built_in">f</span>(a % c, b % c, c, n) + (a / c) * n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + (b / c) * (n + <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> m = (a * n + b) / c;<br>    <span class="hljs-keyword">return</span> n * m - <span class="hljs-built_in">f</span>(c, c - b - <span class="hljs-number">1</span>, a, m - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>同时类欧几里得算法也有两个拓展情况，记为 <spanclass="math inline">\(g\)</span> 函数和 <spanclass="math inline">\(h\)</span> 函数： <span class="math display">\[g(a,b,c,n)=\sum_{x=0}^n \ x\bigg\lfloor \frac{ax+b}{c} \bigg\rfloor\]</span></p><p><span class="math display">\[h(a,b,c,n)=\sum_{x=0}^n \ {\bigg\lfloor \frac{ax+b}{c} \bigg\rfloor}^2\]</span></p><p><span class="math inline">\(g\)</span> 函数的化简：</p><p>首先利用前面的取模化简，将 <span class="math inline">\(g\)</span>函数化简成如下形式： <span class="math display">\[g(a,b,c,n)=\sum_{x=0}^n \ x\bigg\lfloor \frac{(a\ mod\ c)x+(b\ mod\c)}{c} \bigg\rfloor+\bigg\lfloor\frac{a}{c} \bigg\rfloorx^2+\bigg\lfloor\frac{b}{c} \bigg\rfloor x\]</span> 同时根据我们学过的数学知识，有以下两个结论： <spanclass="math display">\[\sum_{i=1}^n i=\frac{n(n + 1)}{2} \\\sum_{i=1}^n i^2 = \frac{n(n+1)(2n+1)}{6}\]</span>（平方和公式的证明，《具体数学》中介绍了几种详细证明的方式）</p><p>那么原式就被我们化简成了： <span class="math display">\[g(a,b,c,n)=\frac{n(n+1)(2n+1)}{6}\times\bigg\lfloor\frac{a}{c}\bigg\rfloor + \frac{n(n+1)}{2}\times\bigg\lfloor\frac{b}{c}\bigg\rfloor + g(a\ mod\ c,b\ mod\ c,c,n)\]</span> 取模化简结束之后在进行贡献化简，利用同样的方式，令 <spanclass="math inline">\(m=\big\lfloor \frac{an+b}{c}\big\rfloor\)</span>，原式化简成： <span class="math display">\[\sum_{j=0}^{m-1}\sum_{x=0}^n\ x\bigg[x &gt; \bigg\lfloor\frac{cj+c-b-1}{a} \bigg\rfloor\bigg]\]</span> 观察后面的和式部分，同时令 <spanclass="math inline">\(t=\big\lfloor\frac{cj+c-b-1}{a}\big\rfloor\)</span>，则后面的和式部分变为： <spanclass="math display">\[\sum_{x=0}^n\ x[x &gt; t]\]</span> 观察不难发现，只有当 <span class="math inline">\(x\geqt+1\)</span> 时，才会产生贡献，因此和式部分就转化成了： <spanclass="math display">\[\sum_{x=t+1}^n\ x\]</span> 那么这个部分就变成了首项为 <spanclass="math inline">\(t+1\)</span> ，末项为 <spanclass="math inline">\(n\)</span>，公差为 <spanclass="math inline">\(1\)</span> 的等差数列了，那么容易得到： <spanclass="math display">\[\sum_{x=t+1}^n\ x=\frac{(t + 1 + n) \times (n - t)}{2}\]</span> 但这样子看还是太复杂了，再进行化简： <spanclass="math display">\[\begin{align*}\frac{(t + 1 + n) \times (n - t)}{2} &amp;=\frac{nt-t^2+n-t+n^2-nt}{2}\\&amp;=\frac{n^2+n}{2}-\frac{t^2+t}{2}\end{align*}\]</span> 那么原式就变成了： <span class="math display">\[\begin{align*}g(a,b,c,n)&amp;=\sum_{j=0}^{m-1}\ \frac{n^2+n}{2}-\frac{t^2+t}{2}\\&amp;=\frac{1}{2}\bigg(\sum_{j=0}^{m-1}(n^2+n)-\sum_{j=0}^{m-1}(t^2+t)\bigg)\end{align*}\]</span> 此时前面的和式中， <span class="math inline">\(n\)</span> 和<span class="math inline">\(j\)</span>没有任何联系了，可以尝试转化为公式进行解决，然后对后面的和式进行拆分：</p><p><span class="math display">\[g(a,b,c,n)=\frac{1}{2}\bigg(m(n^2+n)-\sum_{j=0}^{m-1}t^2-\sum_{j=0}^{m-1}t\bigg)\]</span> 将 <span class="math inline">\(t=\big\lfloor\frac{cj+c-b-1}{a}\big\rfloor\)</span> 代回原式子中： <spanclass="math display">\[g(a,b,c,n)=\frac{1}{2}\bigg(m(n^2+n) -\sum_{j=0}^{m-1}{\bigg\lfloor\frac{cj+c-b-1}{a}\bigg\rfloor}^2-\sum_{j=0}^{m-1}\bigg\lfloor\frac{cj+c-b-1}{a}\bigg\rfloor\bigg)\]</span> 观察得到第一个和式部分为等会要解决的 <spanclass="math inline">\(h\)</span> 函数，第二个和式部分为 <spanclass="math inline">\(f\)</span> 函数，最终式子化为： <spanclass="math display">\[g(a,b,c,n)=\frac{1}{2}\bigg(m(n^2+n)-h(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)\bigg)\]</span> 那么接下来要解决的就是 <span class="math inline">\(h\)</span>函数的化简了。</p><p><span class="math inline">\(h\)</span> 函数的化简：</p><p>同样的进行取模化简： <span class="math display">\[\begin{align*}h(a,b,c,n)&amp;=\sum_{x=0}^n \bigg(\ \bigg\lfloor \frac{(a\ mod\ c)x+(b\mod\ c)}{c} \bigg\rfloor+\bigg\lfloor\frac{a}{c} \bigg\rfloorx+\bigg\lfloor\frac{b}{c}\bigg\rfloor\bigg)^2\\&amp;=\sum_{x=0}^n\bigg\lfloor \frac{(a\ mod\ c)x+(b\ mod\ c)}{c}\bigg\rfloor^2+2\times\bigg\lfloor \frac{(a\ mod\ c)x+(b\ mod\ c)}{c}\bigg\rfloor\times\bigg(\bigg\lfloor\frac{a}{c} \bigg\rfloorx+\bigg\lfloor\frac{b}{c}\bigg\rfloor\bigg)\\&amp;+\bigg(\bigg\lfloor\frac{a}{c} \bigg\rfloorx+\bigg\lfloor\frac{b}{c}\bigg\rfloor\bigg)^2\\&amp;=\sum_{x=0}^n\bigg\lfloor \frac{(a\ mod\ c)x+(b\ mod\ c)}{c}\bigg\rfloor^2+2\bigg\lfloor\frac{a}{c}\bigg\rfloor\sum_{x=0}^nx\bigg\lfloor \frac{(a\ mod\ c)x+(b\ mod\ c)}{c}\bigg\rfloor\\&amp;+2\bigg\lfloor\frac{b}{c} \bigg\rfloor\sum_{x=0}^n\bigg\lfloor\frac{(a\ mod\ c)x+(b\ mod\ c)}{c}\bigg\rfloor+\sum_{x=0}^n\bigg(\bigg\lfloor\frac{a}{c}\bigg\rfloor^2x^2+2\bigg\lfloor\frac{a}{c}\bigg\rfloor\bigg\lfloor\frac{b}{c} \bigg\rfloorx+\bigg\lfloor\frac{b}{c} \bigg\rfloor^2\bigg)\\&amp;=h(a\ mod\ c,b\ mod\ c,c,n)+2\bigg\lfloor\frac{a}{c} \bigg\rfloorg(a\ mod\ c,b\ mod\ c,c,n)\\&amp;+2\bigg\lfloor\frac{b}{c} \bigg\rfloor f(a\ mod\ c,b\ mod\c,c,n)+\bigg\lfloor\frac{a}{c}\bigg\rfloor^2\times\frac{n(n+1)(2n+1)}{6}+\bigg\lfloor\frac{a}{c}\bigg\rfloor\bigg\lfloor\frac{b}{c} \bigg\rfloor\times{n(n+1)}\\&amp;+\bigg\lfloor\frac{b}{c} \bigg\rfloor^2\times(n+1)\end{align*}\]</span> 取模化简的部分结束之后，在进行贡献化简： <spanclass="math display">\[h(a,b,c,n)=\sum_{x=0}^n \ {\bigg\lfloor \frac{ax+b}{c} \bigg\rfloor}^2\]</span>注意到平方是比较难以处理的，但我们可以通过巧妙的方式来进行降幂： <spanclass="math display">\[t^2=2\times\frac{t(t+1)}{2}-t=\bigg(2\sum_{x=1}^tx\bigg)-t\]</span> 那么将 <span class="math inline">\(t\)</span> 替换成 <spanclass="math inline">\({\big\lfloor \frac{ax+b}{c}\big\rfloor}\)</span>，原式就转化成了： <span class="math display">\[\begin{align*}h(a,b,c,n)&amp;=\sum_{x=0}^n\bigg(\bigg(2\sum_{j=1}^{\big\lfloor\frac{ax+b}{c} \big\rfloor}j\bigg)-\bigg\lfloor \frac{ax+b}{c}\bigg\rfloor\bigg) \\&amp;=2\sum_{x=0}^n\sum_{j=1}^{\big\lfloor \frac{ax+b}{c} \big\rfloor}j\-f(a,b,c,n)\end{align*}\]</span> 那么关键就在于前面的和式部分的化简了： <spanclass="math display">\[\sum_{x=0}^n\sum_{j=1}^{\big\lfloor \frac{ax+b}{c}\big\rfloor}j=\sum_{x=0}^n\sum_{j=0}^{\big\lfloor \frac{ax+b}{c}\big\rfloor-1}(j+1)=\sum_{j=0}^{\big\lfloor \frac{an+b}{c}\big\rfloor-1}(j+1)\sum_{x=0}^n\bigg[j&lt;\bigg\lfloor\frac{ax+b}{c}\bigg\rfloor\bigg]\]</span>转化到这一步，就是前面比较熟悉的贡献化简的过程了，因此最终转化为： <spanclass="math display">\[\sum_{j=0}^{\big\lfloor \frac{an+b}{c}\big\rfloor-1}(j+1)\sum_{x=0}^n\bigg[x &gt; \bigg\lfloor\frac{cj+c-b-1}{a} \bigg\rfloor\bigg]=\sum_{j=0}^{\big\lfloor\frac{an+b}{c} \big\rfloor-1}\bigg((j+1)\times\bigg(n- \bigg\lfloor\frac{cj+c-b-1}{a} \bigg\rfloor\bigg)\bigg)\]</span> 那么对后面的部分进行拆分，同时令 <spanclass="math inline">\(m=\big\lfloor\frac{an+b}{c}\big\rfloor\)</span>，就会得到： <spanclass="math display">\[\sum_{j=0}^{m-1}jn-\sum_{j=0}^{m-1}\ j\bigg\lfloor \frac{cj+c-b-1}{a}\bigg\rfloor+\sum_{j=0}^{m-1}n-\sum_{j=0}^{m-1}\ \bigg\lfloor\frac{cj+c-b-1}{a} \bigg\rfloor\]</span> 四个和式部分都是我们非常熟悉的，再次进行化简： <spanclass="math display">\[\frac{nm(m-1)}{2}-g(c,c-b-1,a,m-1)+nm-f(c,c-b-1,a,m-1)\]</span> 将化简后的部分代回原式当中： <span class="math display">\[\begin{align*}h(a,b,c,n)&amp;=nm(m-1)-2g(c,c-b-1,a,m-1)+2nm-2f(c,c-b-1,a,m-1)-f(a,b,c,n)\\&amp;=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)\end{align*}\]</span> 那么最终 <span class="math inline">\(g\)</span> 函数和 <spanclass="math inline">\(h\)</span> 函数被我们化简成了一下两个部分：</p><p><span class="math inline">\(g\)</span> 函数：</p><p>当 <span class="math inline">\(a\geq c\)</span> 或 <spanclass="math inline">\(b\geq c\)</span> 时： <spanclass="math display">\[g(a,b,c,n)=\frac{n(n+1)(2n+1)}{6}\times\bigg\lfloor\frac{a}{c}\bigg\rfloor + \frac{n(n+1)}{2}\times\bigg\lfloor\frac{b}{c}\bigg\rfloor + g(a\ mod\ c,b\ mod\ c,c,n)\]</span> 当 <span class="math inline">\(a &lt; c\)</span> 且 <spanclass="math inline">\(b&lt;c\)</span> 时： <span class="math display">\[g(a,b,c,n)=\frac{1}{2}\bigg(m(n^2+n)-h(c,c-b-1,a,m-1)-f(c,c-b-1,a,m-1)\bigg)\]</span> <span class="math inline">\(h\)</span> 函数：</p><p>当 <span class="math inline">\(a\geq c\)</span> 或 <spanclass="math inline">\(b\geq c\)</span> 时： <spanclass="math display">\[\begin{align*}h(a,b,c,n)&amp;=h(a\ mod\ c,b\ mod\ c,c,n)+2\bigg\lfloor\frac{a}{c}\bigg\rfloor g(a\ mod\ c,b\ mod\ c,c,n)\\&amp;+2\bigg\lfloor\frac{b}{c} \bigg\rfloor f(a\ mod\ c,b\ mod\c,c,n)+\bigg\lfloor\frac{a}{c}\bigg\rfloor^2\times\frac{n(n+1)(2n+1)}{6}+\bigg\lfloor\frac{a}{c}\bigg\rfloor\bigg\lfloor\frac{b}{c} \bigg\rfloor\times{n(n+1)}\\&amp;+\bigg\lfloor\frac{b}{c} \bigg\rfloor^2\times(n+1)\end{align*}\]</span> 当 <span class="math inline">\(a &lt; c\)</span> 且 <spanclass="math inline">\(b&lt;c\)</span> 时： <span class="math display">\[h(a,b,c,n)=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)\]</span> 观察可以发现在求解 <span class="math inline">\(f\)</span>函数，<span class="math inline">\(g\)</span> 函数和 <spanclass="math inline">\(h\)</span>函数的时候需要互相使用，因此类欧几里得算法的这三个函数一般都是一起进行处理的，除非只需要求解<span class="math inline">\(f\)</span> 函数时调用上面 <spanclass="math inline">\(f\)</span> 函数的代码实现即可。</p><p>时间复杂度：<span class="math inline">\(O(logn)\)</span></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-keyword">constexpr</span> ll mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> ll i2 = <span class="hljs-number">499122177</span>;      <span class="hljs-comment">// 2的逆元</span><br><span class="hljs-keyword">constexpr</span> ll i6 = <span class="hljs-number">166374059</span>;     <span class="hljs-comment">// 6的逆元</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Data</span><br>&#123;<br>    ll f, g, h;<br>&#125;;<br><br><span class="hljs-function">Data <span class="hljs-title">calc</span><span class="hljs-params">(ll a, ll b, ll c, ll n)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ac = a / c, bc = b / c, m = (a * n + b) / c;<br>    <span class="hljs-keyword">if</span>(a == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;bc * (n + <span class="hljs-number">1</span>) % mod, bc * n % mod * (n + <span class="hljs-number">1</span>) % mod * i2 % mod, bc * bc % mod * (n + <span class="hljs-number">1</span>) % mod&#125;;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a &gt;= c || b &gt;= c)<br>    &#123;<br>        ll tmpf = (n * (n + <span class="hljs-number">1</span>) % mod * i2 % mod * ac % mod + (n + <span class="hljs-number">1</span>) * bc % mod) % mod;<br>        ll tmpg = (n * (n + <span class="hljs-number">1</span>) % mod * (<span class="hljs-number">2ll</span> * n + <span class="hljs-number">1</span>) % mod * i6 % mod * ac % mod + n * (n + <span class="hljs-number">1</span>) % mod * i2 % mod * bc) % mod;<br>        ll tmph = (n * (n + <span class="hljs-number">1</span>) % mod * (<span class="hljs-number">2ll</span> * n + <span class="hljs-number">1</span>) % mod * i6 % mod * ac % mod * ac % mod + <br>                   n * (n + <span class="hljs-number">1</span>) % mod * ac % mod * bc % mod + (n + <span class="hljs-number">1</span>) * bc % mod * bc % mod) % mod;<br>        <br>        <span class="hljs-keyword">auto</span> tmp = <span class="hljs-built_in">calc</span>(a % c, b % c, c, n);<br>        tmpf = (tmpf + tmp.f) % mod;<br>        tmpg = (tmpg + tmp.g) % mod;<br>        tmph = (tmph + tmp.h + <span class="hljs-number">2ll</span> * ac % mod * tmp.g % mod + <span class="hljs-number">2ll</span> * bc % mod * tmp.f % mod) % mod;<br>        <br>        <span class="hljs-keyword">return</span> &#123;tmpf, tmpg, tmph&#125;;<br>    &#125;<br>    <br>    ll tmpf = n * m % mod;<br>    ll tmpg = m * n % mod * (n + <span class="hljs-number">1</span>) % mod;<br>    ll tmph = n * m % mod * (m + <span class="hljs-number">1</span>) % mod;<br><br>    <span class="hljs-keyword">auto</span> tmp = <span class="hljs-built_in">calc</span>(c, c - b - <span class="hljs-number">1</span>, a, m - <span class="hljs-number">1</span>);<br>    tmpf = tmpf - tmp.f; tmpf = (tmpf % mod + mod) % mod;<br>    tmpg = tmpg - tmp.h - tmp.f; tmpg = (tmpg * i2 % mod + mod) % mod;<br>    tmph = tmph - <span class="hljs-number">2ll</span> * tmp.g - <span class="hljs-number">2ll</span> * tmp.f  - tmpf; tmph = (tmph % mod + mod) % mod;<br><br>    <span class="hljs-keyword">return</span> &#123;tmpf, tmpg, tmph&#125;;  <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> t;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span>(t -- )<br>    &#123;<br>        ll n, a, b, c;<br>        cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        <span class="hljs-keyword">auto</span> ans = <span class="hljs-built_in">calc</span>(a, b, c, n);<br>        cout &lt;&lt; ans.f &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ans.h &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ans.g &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stern-Brocot 树与 Farey 序列</title>
    <link href="/2024/01/15/Stern-Brocot-%E6%A0%91%E4%B8%8E-Farey-%E5%BA%8F%E5%88%97/"/>
    <url>/2024/01/15/Stern-Brocot-%E6%A0%91%E4%B8%8E-Farey-%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="sternbrocot-树与-farey-序列">Stern–Brocot 树与 Farey 序列</h1><p>参考资料：</p><p>OI-Wiki: <ahref="http://oi-wiki.com/math/number-theory/stern-brocot/">Stern–Brocot树与 Farey 序列 - OI Wiki (oi-wiki.com)</a></p><h4 id="sternbrocot-树">Stern–Brocot 树</h4><p><strong>定义：</strong></p><p><span class="math inline">\(\text{Stern–Brocot}\)</span>树是一种维护分数的优雅的结构，包含所有不同的正有理数。这个结构由 <spanclass="math inline">\(\text{Moritz Stern}\)</span> 在 1858 年和 <spanclass="math inline">\(\text{Achille Brocot}\)</span> 在 1861年发现。</p><p><strong>解释：</strong></p><p><span class="math inline">\(\text{Stern–Brocot}\)</span>树从两个简单的分数开始：<spanclass="math inline">\(\frac{0}{1},\frac{1}{0}\)</span></p><p>其中 <span class="math inline">\(\frac{1}{0}\)</span> 把它当作 <spanclass="math inline">\(\infty\)</span>即可，后续会了解这么设计的巧妙之处。</p><p>每次在相邻的两个分数 <spanclass="math inline">\(\frac{a}{b},\frac{c}{d}\)</span> 中间插入一个分数<spanclass="math inline">\(\frac{a+c}{b+d}\)</span>，这样就完成了一次迭代，得到下一个序列，于是它就会变成如下形式：<span class="math display">\[\begin{align}\frac{0}{1},&amp;\frac{1}{1},\frac{1}{0} \\\frac{0}{1},\frac{1}{2},&amp;\frac{1}{1},\frac{2}{1},\frac{1}{0} \\\frac{0}{1},\frac{1}{3},\frac{1}{2},\frac{2}{3},&amp;\frac{1}{1},\frac{3}{2},\frac{2}{1},\frac{3}{1},\frac{1}{0}\end{align}\]</span> 既然称它为 <spanclass="math inline">\(\text{Stern–Brocot}\)</span>树，那我们转化成树的样子，变成如下形式：</p><figure><img src="/images/stern-brocot.png" alt="Stern–Brocot树" /><figcaption aria-hidden="true">Stern–Brocot树</figcaption></figure><p>其中，实线为树边，虚线为方便看中序遍历而所作的辅助线，此时我们可以把第<span class="math inline">\(i\)</span> 层的序列当作是深度为 <spanclass="math inline">\(i-1\)</span> 的 <spanclass="math inline">\(\text{Stern–Brocot}\)</span> 树的中序遍历。</p><p><strong>性质：</strong></p><p>单调性：在每一层的序列中，真分数是单调递增的。</p><p>略证：只需要在 <spanclass="math inline">\(\frac{a}{c}\leq\frac{c}{d}\)</span> 的情况下证明<spanclass="math inline">\(\frac{a}{b}\leq\frac{a+c}{b+d}\leq\frac{c}{d}\)</span>即可。 <span class="math display">\[\frac{a}{b}\leq\frac{c}{d}\Rightarrowad\leq bc\Rightarrowad+ab\leq bc+ab\Rightarrow\frac{a}{b}\leq\frac{a+c}{b+d}\]</span></p><p><span class="math display">\[\frac{a}{b}\leq\frac{c}{d}\Rightarrowad\leq bc\Rightarrowad+cd\leq bc+cd\Rightarrow\frac{a+c}{b+d}\leq\frac{c}{d}\]</span></p><p>最简性：序列中的分数（除了 <spanclass="math inline">\(\frac{0}{1},\frac{1}{0}\)</span>）都是最简分数。</p><p>略证：</p><p>为证明最简性，我们首先证明对于序列中连续的两个分数 <spanclass="math inline">\(\frac{a}{b},\frac{c}{d}:\ bc-ad=1\)</span></p><p>显然，只需要在 <span class="math inline">\(bc-ad=1\)</span>的条件下证明 <spanclass="math inline">\(\frac{a}{b},\frac{a+c}{b+d},\frac{c}{d}\)</span>的情况成立即可。 而对于 <spanclass="math inline">\(\frac{a}{b},\frac{a+c}{b+d}\)</span>，有 <spanclass="math inline">\(b(a+c)-a(b+d)=bc-ad=1\)</span>，并且对于 <spanclass="math inline">\(\frac{a+c}{b+d},\frac{c}{d}\)</span>，有 <spanclass="math inline">\(c(b+d)-d(a+c)=bc-ad=1\)</span>。 同时对于 <spanclass="math inline">\(\frac{0}{1},\frac{1}{0}\)</span>显然成立，因此结合上述结论，我们就证完了序列中连续的两个分数 <spanclass="math inline">\(\frac{a}{b},\frac{c}{d}\)</span> 满足 <spanclass="math inline">\(bc-ad=1\)</span>。</p><p>得到这个式子之后，通过扩展欧几里得的知识点即可得到 <spanclass="math inline">\(gcd(a,b)=1,gcd(c,d)=1\)</span>。因此序列中的分数都是最简分数。同时因为 <span class="math inline">\(bc-ad=1\)</span>，我们可以推出<span class="math inline">\(bc=ad+1\)</span> ，即 <spanclass="math inline">\(bc&gt;ad\)</span>，进一步可以得到 <spanclass="math inline">\(\frac{a}{b}&lt;\frac{c}{d}\)</span>。</p><p>有了这两个性质，就能把 <spanclass="math inline">\(\text{Stern–Brocot}\)</span>树当成一颗平衡树来做，建立和查询与平衡树一致。</p><h4 id="farey-序列">Farey 序列</h4><p>待补。</p>]]></content>
    
    
    <categories>
      
      <category>数论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ABC334</title>
    <link href="/2024/01/10/ABC334/"/>
    <url>/2024/01/10/ABC334/</url>
    
    <content type="html"><![CDATA[<h4 id="a.-christmas-present">A. Christmas Present</h4><p>签到，若 <span class="math inline">\(B&gt;G\)</span> 则输出 <spanclass="math inline">\(\text{Bat}\)</span> ，否则输出 <spanclass="math inline">\(\text{Glove}\)</span>。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 200005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> lll = __int128;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(false);</span><br>    <span class="hljs-comment">// cin.tie(0);</span><br>    <span class="hljs-comment">// cout.tie(0);</span><br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        <span class="hljs-type">int</span> b, g;<br>        cin &gt;&gt; b &gt;&gt; g;<br>        <span class="hljs-keyword">if</span>(b &gt; g) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Bat&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Glove&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="b.-christmas-trees">B. Christmas Trees</h4><p>题意：给定你一个起点 <span class="math inline">\(A\)</span> 和间隔<span class="math inline">\(M\)</span> ，让你以 <spanclass="math inline">\(A\)</span> 点为起点，每间隔 <spanclass="math inline">\(M\)</span> 个长度就种一棵树（包括 <spanclass="math inline">\(A\)</span> 点），形式化的讲，<spanclass="math inline">\(A+kM\)</span> 位置上都有一棵树，其中<spanclass="math inline">\(k=...,-2,-1,0,1,2,...\)</span>。现问区间 <spanclass="math inline">\([L,R]\)</span> 之间有多少棵树。</p><p>只需要拆成两个区间，即 <span class="math inline">\([A,L]\)</span> 和<span class="math inline">\([A,R]\)</span> 两个区间进行计算即可，根据在<span class="math inline">\(A\)</span>的左侧还是右侧具体进行判断，同时判断两个区间个数是相加还是相减即可。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 200005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> lll = __int128;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        ll a, m, l, r;<br>        cin &gt;&gt; a &gt;&gt; m &gt;&gt; l &gt;&gt; r;<br>        ll ans;<br>        <span class="hljs-keyword">if</span>(l &gt; a) ans = (r - a) / m - (l - <span class="hljs-number">1</span> - a) / m;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(r &lt; a) ans = (a - l) / m - (a - r - <span class="hljs-number">1</span>) / m;<br>        <span class="hljs-keyword">else</span> ans = (r - a) / m + (a - l) / m + <span class="hljs-number">1</span>;<br>        cout &lt;&lt; ans &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="c.-socks-2">C. Socks 2</h4><p>题意：有 <span class="math inline">\(N\)</span> 双袜子，但其中有<span class="math inline">\(K\)</span> 双袜子缺了一只，现在将 <spanclass="math inline">\(2N-K\)</span>只袜子重新组合，求怪异度最低的值，一双袜子的怪异度等于这双袜子其中一只袜子<span class="math inline">\(i\)</span> 和另一只袜子 <spanclass="math inline">\(j\)</span> 的差值的绝对值，即 <spanclass="math inline">\(|i-j|\)</span>。</p><p>观察发现：两只各自已缺的袜子之间无论夹着多少双没有缺的袜子，总的最小怪异度不会发生改变，即都是两只各自缺的袜子的怪异度值，因此，我们只需要考虑怎么把单只袜子组成起来，求最小的怪异度值。</p><p>面对偶数只袜子时，从小到大排序两两组合即可得到最小的怪异度值。</p><p>面对奇数只袜子时，肯定要扔掉一只袜子，因此只需要暴力枚举需要扔掉的袜子，不断更新能组成的最小怪异值即可，最后枚举完输出答案即可。并且，我们在枚举的过程中需要跳一个枚举，也就是枚举第<span class="math inline">\(i\)</span> 个时， 下一个枚举的是 <spanclass="math inline">\(i+2\)</span>，如果下一个枚举的是 <spanclass="math inline">\(i+1\)</span>，怪异值不会发生减少（可以自己在草稿纸试一试）。枚举的时候，我们可以从小到大两两组合，那么此时枚举扔掉的袜子就是编号最大的那只袜子，然后一直往编号递减的袜子枚举，每次枚举记录当前值<span class="math inline">\(now\)</span>，那么更新 <spanclass="math inline">\(now\)</span>的方式就变成了删除前两个的差值绝对值，然后加上当前和前一个的差值的绝对值，最后用<span class="math inline">\(now\)</span> 更新答案即可。</p><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 200005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> lll = __int128;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br><span class="hljs-type">int</span> a[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i ++ ) cin &gt;&gt; a[i];<br>        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> res;<br>            <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= k; i += <span class="hljs-number">2</span>) ans += a[i] - a[i - <span class="hljs-number">1</span>];<br>            res = ans;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = k - <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i -= <span class="hljs-number">2</span>)<br>            &#123;<br>                ans -= a[i + <span class="hljs-number">1</span>] - a[i];<br>                ans += a[i + <span class="hljs-number">2</span>] - a[i + <span class="hljs-number">1</span>];<br>                res = <span class="hljs-built_in">min</span>(res, ans);<br>            &#125;<br>            cout &lt;&lt; res &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= k; i += <span class="hljs-number">2</span>) ans += a[i] - a[i - <span class="hljs-number">1</span>];<br>            cout &lt;&lt; ans &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="d.-reindeer-and-sleigh">D. Reindeer and Sleigh</h4><p>题意：有 <span class="math inline">\(N\)</span> 个雪橇，每个雪橇<span class="math inline">\(i\)</span> 需要 <spanclass="math inline">\(R_i\)</span> 只驯鹿才能拉动，现有 <spanclass="math inline">\(Q\)</span> 次询问，每次询问你 <spanclass="math inline">\(X\)</span> 只驯鹿，问这 <spanclass="math inline">\(X\)</span> 只驯鹿最多能拉几个雪橇。</p><p>很简单的从小到大排序，然后前缀和预处理，最后二分答案解决每次询问即可。</p><p>时间复杂度：<span class="math inline">\(O(nlogn)\)</span></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 200005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> lll = __int128;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br><span class="hljs-type">int</span> a[N];<br>ll sum[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        <span class="hljs-type">int</span> n, q;<br>        cin &gt;&gt; n &gt;&gt; q;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; a[i];<br>        <span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];<br>        <span class="hljs-keyword">while</span>(q -- )<br>        &#123;<br>            ll x;<br>            cin &gt;&gt; x;<br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n;<br>            <span class="hljs-keyword">while</span>(l &lt; r)<br>            &#123;<br>                <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span>(x &gt;= sum[mid]) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            cout &lt;&lt; l &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="e.-christmas-color-grid-1">E. Christmas Color Grid 1</h4><p>题意：有 <span class="math inline">\(H\)</span> 行 <spanclass="math inline">\(W\)</span> 列，每个位置上，若 <spanclass="math inline">\(.\)</span> 表示当前格子为红色，若 #表示当前格子为绿色，问随机选取一个红色格子，然后改成绿色后，绿色连通块的数量期望是多少。</p><p>用并查集处理绿色连通块的数量并记为 <spanclass="math inline">\(num\)</span>，然后枚举每一个红色格子，如果红色格子周围有<span class="math inline">\(x\)</span>个不同的绿色连通块，那么分子上就加上 <spanclass="math inline">\(num-x+1\)</span>，分母为红色格子的数量，期望即为上述的分子除以分母，答案为 <spanclass="math inline">\(998244353\)</span> 取模，那么求逆元即可。</p><p>二维数组做并查集一个可行技巧是把二维数组用计数器或者公式映射成一维数组，然后用一维数组的方式使用并查集即可。</p><p>时间复杂度：<span class="math inline">\(O(HW)\)</span></p><p>（下面代码可以使用 <span class="math inline">\(dx[4]\)</span> 和<span class="math inline">\(dy[4]\)</span>优化代码行数，这里我懒得改了）</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> lll = __int128;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br>string s[<span class="hljs-number">1005</span>];<br><span class="hljs-type">int</span> fa[N];<br><span class="hljs-type">int</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(fa[x] == x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">qp</span><span class="hljs-params">(ll b, ll p)</span></span><br><span class="hljs-function"></span>&#123;<br>    ll ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(p)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p &amp; <span class="hljs-number">1</span>) ans = ans * b % MOD;<br>        b = b * b % MOD;<br>        p &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function">ll <span class="hljs-title">inv</span><span class="hljs-params">(ll x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qp</span>(x % MOD, MOD - <span class="hljs-number">2</span>) % MOD;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(false);</span><br>    <span class="hljs-comment">// cin.tie(0);</span><br>    <span class="hljs-comment">// cout.tie(0);</span><br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        <span class="hljs-type">int</span> h, w;<br>        cin &gt;&gt; h &gt;&gt; w;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; i ++ ) cin &gt;&gt; s[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; i ++ ) s[i] = <span class="hljs-string">&quot;!&quot;</span> + s[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h * w; i ++ ) fa[i] = i;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; i ++ )<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= w; j ++ )<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &lt;= h &amp;&amp; s[i + <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-type">int</span> idx1 = (i - <span class="hljs-number">1</span>) * w + j, idx2 = i * w + j;<br>                        <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(idx1), v = <span class="hljs-built_in">find</span>(idx2);<br>                        <span class="hljs-keyword">if</span>(u != v) fa[u] = v;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span>(j + <span class="hljs-number">1</span> &lt;= w &amp;&amp; s[i][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                    &#123;<br>                        <span class="hljs-type">int</span> idx1 = (i - <span class="hljs-number">1</span>) * w + j, idx2 = (i - <span class="hljs-number">1</span>) * w + j + <span class="hljs-number">1</span>;<br>                        <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(idx1), v = <span class="hljs-built_in">find</span>(idx2);<br>                        <span class="hljs-keyword">if</span>(u != v) fa[u] = v;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        ll num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; i ++ )<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= w; j ++ )<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i][j] != <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> idx = (i - <span class="hljs-number">1</span>) * w + j;<br>                <span class="hljs-type">int</span> father = <span class="hljs-built_in">find</span>(idx);<br>                <span class="hljs-keyword">if</span>(!vis[father]) num ++ , vis[father] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        ll red = <span class="hljs-number">0</span>;<br>        ll tot = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; i ++ )<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= w; j ++ )<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                red ++ ;<br>                set&lt;<span class="hljs-type">int</span>&gt; st;<br>                <span class="hljs-type">int</span> idx;<br>                <span class="hljs-keyword">if</span>(i - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; s[i - <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123;<br>                    idx = (i - <span class="hljs-number">2</span>) * w + j;<br>                    st.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">find</span>(idx));<br>                &#125;<br>                <span class="hljs-keyword">if</span>(i + <span class="hljs-number">1</span> &lt;= h &amp;&amp; s[i + <span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123; <br>                    idx = i * w + j;<br>                    st.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">find</span>(idx));<br>                &#125;<br>                <span class="hljs-keyword">if</span>(j - <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span> &amp;&amp; s[i][j - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123; <br>                    idx = (i - <span class="hljs-number">1</span>) * w + j - <span class="hljs-number">1</span>;<br>                    st.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">find</span>(idx));<br>                &#125;<br>                <span class="hljs-keyword">if</span>(j + <span class="hljs-number">1</span> &lt;= w &amp;&amp; s[i][j + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123; <br>                    idx = (i - <span class="hljs-number">1</span>) * w + j + <span class="hljs-number">1</span>;<br>                    st.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">find</span>(idx));<br>                &#125;<br>                <span class="hljs-type">int</span> len = st.<span class="hljs-built_in">size</span>();<br>                tot = (tot + num - len + <span class="hljs-number">1</span>) % MOD;<br>            &#125;<br>        &#125;<br>        ll res = tot * <span class="hljs-built_in">inv</span>(red) % MOD;<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="f.-christmas-present-2">F. Christmas Present 2</h4><p>题意：圣诞老人在坐标 <span class="math inline">\((S_X,S_Y)\)</span>点上，第 <span class="math inline">\(i\)</span> 个孩子在 <spanclass="math inline">\((X_i,Y_i)\)</span> 点上，有 <spanclass="math inline">\(N\)</span> 个孩子，现在圣诞老人最多只能带着 <spanclass="math inline">\(K\)</span> 个礼物，从 <spanclass="math inline">\(1 \sim N\)</span>的顺序给孩子送礼物，每个孩子一个礼物，送完 <spanclass="math inline">\(K\)</span>个礼物圣诞老人需要回到出发点补货，问最短路径是多少。</p><p>思路：</p><p>最重要的一个点在于是从 <span class="math inline">\(1-N\)</span>的顺序给孩子送礼物，因此问题就成功转化成了一个 <spanclass="math inline">\(DP\)</span> 问题，同时也能很轻松的列出 <spanclass="math inline">\(DP\)</span> 式子： <span class="math display">\[dp[i] = \mathop{min} \limits_{i-K+1\leq j\leqi}(dp[j-1]-sum[j]+w[j])+sum[i]+w[i]\]</span> 其中 <span class="math inline">\(sum[i]\)</span> 表示前 <spanclass="math inline">\(i\)</span> 个点中两两连续点距离的总和，即 <spanclass="math inline">\(1\sim 2,2\sim 3,...,i-1\sim i\)</span> 这 <spanclass="math inline">\(i-1\)</span> 对点的距离的总和。而 <spanclass="math inline">\(w[i]\)</span> 表示第 <spanclass="math inline">\(i\)</span> 个点到点 <spanclass="math inline">\((S_X,S_Y)\)</span>的距离，由于圣诞老人最多只能带着 <span class="math inline">\(K\)</span>个礼物，因此转移的时候只能从前 <span class="math inline">\(K\)</span>个状态转移过来，这个就启发使用滑动窗口来不断进行维护更新状态，那么维护滑动窗口很容易就想到使用单调队列来进行优化，从而通过此题。</p><p>当然前 <span class="math inline">\(K\)</span>个状态的最小值也可以使用线段树来进行维护，但是明显的用单调队列维护滑动窗口没必要上那么难写的数据结构折磨自己，与其用线段树，不如练一下遗忘已久的单调队列来的好，单调队列优化的<span class="math inline">\(DP\)</span> 问题也是需要重点掌握的。</p><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> lll = __int128;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br><span class="hljs-type">double</span> x[N], y[N];<br><span class="hljs-type">double</span> w[N], dis[N];<br><span class="hljs-type">double</span> sum[N];<br><span class="hljs-type">double</span> dp[N];<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">int</span> hh, tt;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getdist</span><span class="hljs-params">(<span class="hljs-type">double</span> x1, <span class="hljs-type">double</span> y1, <span class="hljs-type">double</span> x2, <span class="hljs-type">double</span> y2)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span>((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(false);</span><br>    <span class="hljs-comment">// cin.tie(0);</span><br>    <span class="hljs-comment">// cout.tie(0);</span><br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        <span class="hljs-type">int</span> n, k;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-type">double</span> sx, sy;<br>        cin &gt;&gt; sx &gt;&gt; sy;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) cin &gt;&gt; x[i] &gt;&gt; y[i]; <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) w[i] = <span class="hljs-built_in">getdist</span>(sx, sy, x[i], y[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ ) dis[i] = <span class="hljs-built_in">getdist</span>(x[i - <span class="hljs-number">1</span>], y[i - <span class="hljs-number">1</span>], x[i], y[i]);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ ) sum[i] += sum[i - <span class="hljs-number">1</span>] + dis[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        &#123;<br>            <span class="hljs-keyword">while</span>(hh &lt;= tt &amp;&amp; dp[q[tt]] - sum[q[tt] + <span class="hljs-number">1</span>] + w[q[tt] + <span class="hljs-number">1</span>] &gt;= dp[i - <span class="hljs-number">1</span>] - sum[i] + w[i]) tt -- ;<br>            q[++ tt] = i - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(hh &lt;= tt &amp;&amp; i - q[hh] &gt; k) hh ++ ;<br>            dp[i] = dp[q[hh]] - sum[q[hh] + <span class="hljs-number">1</span>] + w[q[hh] + <span class="hljs-number">1</span>] + sum[i] + w[i];<br>        &#125;<br>        cout &lt;&lt; dp[n] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="g.-christmas-color-grid-2">G. Christmas Color Grid 2</h4><p>题意：在 E题题意的基础上，把最后红色改成绿色变为绿色改成红色，其他均一致。</p><p>思路：</p><p>由绿色改为红色，相当于是在原图的基础之上进行删点以及删除该点所连向的边，同时这个操作可能增加连通块的个数。</p><p>那么推导到这里很容易就发现，上述说的就是割点的定义，那么这题就是让我们求哪些点是割点，并且删除掉这些割点会增加多少连通块的数量，那么这就是一个<span class="math inline">\(Tarjan\)</span>算法求图的割点的板子题，不会的抓紧去学 <spanclass="math inline">\(Tarjan\)</span> 算法求割点和桥。</p><p>不过这题给定的不止有一个图，而是多个图，比较容易想到的就是用并查集快速遍历到每个图并对每个图做一次<span class="math inline">\(Tarjan\)</span>算法，最后遍历每一个绿色的点，记录每次删掉这个绿色点之后整个图上的连通块的数量，记为<spanclass="math inline">\(tmp1\)</span>，同时还需要记录整个图中所有绿色点的数量，记为<span class="math inline">\(tmp2\)</span> ，那么答案即为 <spanclass="math inline">\(\frac{tmp1}{tmp2}\)</span>，由于对 <spanclass="math inline">\(998244353\)</span> 取模，需要求逆元。</p><p>到此整个题的思路就讲完了，这个题算是一个多个知识点杂糅在一起的板题罢了，我的做法主要涉及的就是建图+ 并查集 + <span class="math inline">\(Tarjan\)</span> +快速幂求逆元。最后代码只是看着长罢了，写起来并不难，洛谷和 <spanclass="math inline">\(AtCoder\)</span>上也有代码较短的提交，我这里自己写的挺顺的就没去参考别人代码怎么写的了，如果觉得太长可以观摩其他大佬的短代码。</p><p>时间复杂度：<span class="math inline">\(O(HW)\)</span></p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 1000005</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&#x27;\n&#x27;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(), v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sc(t) scanf(<span class="hljs-string">&quot;%d&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scl(t) scanf(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> scf(t) scanf(<span class="hljs-string">&quot;%lf&quot;</span>, &amp;t)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lowbit(x) (x &amp; -x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> x first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y second</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> lll = __int128;<br><span class="hljs-keyword">using</span> ull = <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-keyword">using</span> pii = pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> pi = <span class="hljs-number">3.1415926535897932384</span>;<br><br>string s[<span class="hljs-number">1005</span>];<br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>&#125;;<br><span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> fa[N];<br><span class="hljs-type">int</span> vis[N], number[N];<br><span class="hljs-type">int</span> dfn[N], low[N], block[N], cnt;<br><span class="hljs-type">int</span> root;<br><span class="hljs-type">int</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qp</span><span class="hljs-params">(<span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(p)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(p &amp; <span class="hljs-number">1</span>) ans = <span class="hljs-number">1ll</span> * ans * b % MOD;<br>        b = <span class="hljs-number">1ll</span> * b * b % MOD;<br>        p &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qp</span>(x, MOD - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(fa[x] == x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">find</span>(fa[x]);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    dfn[u] = low[u] = ++ cnt;<br>    block[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v : e[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(!dfn[v])<br>        &#123;<br>            <span class="hljs-built_in">tarjan</span>(v, u);<br>            low[u] = <span class="hljs-built_in">min</span>(low[u], low[v]);<br>            <span class="hljs-keyword">if</span>(low[v] &gt;= dfn[u])<br>            &#123;<br>                flag ++ ;<br>                <span class="hljs-keyword">if</span>(u != root) st[u] = <span class="hljs-number">1</span>, block[u] ++ ;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag &gt; <span class="hljs-number">1</span>) st[u] = <span class="hljs-number">1</span>, block[u] = flag;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> low[u] = <span class="hljs-built_in">min</span>(low[u], dfn[v]);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// ios::sync_with_stdio(false);</span><br>    <span class="hljs-comment">// cin.tie(0);</span><br>    <span class="hljs-comment">// cout.tie(0);</span><br>    cout &lt;&lt; fixed &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">20</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span>(T -- )<br>    &#123;<br>        <span class="hljs-type">int</span> h, w;<br>        cin &gt;&gt; h &gt;&gt; w;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; i ++ ) cin &gt;&gt; s[i], s[i] = <span class="hljs-string">&quot;!&quot;</span> + s[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; i ++ )<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= w; j ++ )<br>            &#123;<br>                <span class="hljs-type">int</span> idx = (i - <span class="hljs-number">1</span>) * w + j;<br>                fa[idx] = idx;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; i ++ )<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= w; j ++ )<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i][j] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-type">int</span> u = (i - <span class="hljs-number">1</span>) * w + j;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k ++ )<br>                &#123;<br>                    <span class="hljs-type">int</span> x = dx[k] + i, y = dy[k] + j;<br>                    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">1</span> || x &gt; h || y &lt; <span class="hljs-number">1</span> || y &gt; w || s[x][y] == <span class="hljs-string">&#x27;.&#x27;</span>) <span class="hljs-keyword">continue</span>;<br>                    <span class="hljs-type">int</span> v = (x - <span class="hljs-number">1</span>) * w + y;<br>                    e[u].<span class="hljs-built_in">push_back</span>(v);<br>                    <span class="hljs-type">int</span> a = <span class="hljs-built_in">find</span>(u), b = <span class="hljs-built_in">find</span>(v);<br>                    <span class="hljs-keyword">if</span>(a != b) fa[a] = b;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; i ++ )<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= w; j ++ )<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-type">int</span> idx = (i - <span class="hljs-number">1</span>) * w + j;<br>                    <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(idx);<br>                    number[u] ++ ;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> tmp1 = <span class="hljs-number">0</span>, tmp2 = <span class="hljs-number">0</span>, num = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; i ++ )<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= w; j ++ )<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123;<br>                    tmp2 ++ ;<br>                    <span class="hljs-type">int</span> idx = (i - <span class="hljs-number">1</span>) * w + j;<br>                    <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(idx);<br>                    <span class="hljs-keyword">if</span>(!vis[u])<br>                    &#123;<br>                        num ++ ;<br>                        cnt = <span class="hljs-number">0</span>;<br>                        root = u;<br>                        <span class="hljs-built_in">tarjan</span>(root, <span class="hljs-number">-1</span>);<br>                        vis[u] = <span class="hljs-number">1</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; i ++ )<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= w; j ++ )<br>            &#123;<br>                <span class="hljs-keyword">if</span>(s[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>                &#123;<br>                    <span class="hljs-type">int</span> idx = (i - <span class="hljs-number">1</span>) * w + j;<br>                    <span class="hljs-keyword">if</span>(st[idx]) tmp1 = (tmp1 + block[idx] - <span class="hljs-number">1</span>) % MOD;<br>                    tmp1 = (tmp1 + num) % MOD;<br>                    <span class="hljs-type">int</span> u = <span class="hljs-built_in">find</span>(idx);<br>                    <span class="hljs-keyword">if</span>(number[u] == <span class="hljs-number">1</span>) tmp1 = (tmp1 % MOD - <span class="hljs-number">1</span> + MOD) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-number">1ll</span> * <span class="hljs-function">tmp1 * <span class="hljs-title">inv</span><span class="hljs-params">(tmp2)</span> % MOD &lt;&lt; endl</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>AtCoder Beginner Contest</category>
      
    </categories>
    
    
    <tags>
      
      <tag>题解</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
